<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>iris</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quickstart/tech_overview.html"><strong aria-hidden="true">2.1.</strong> Technical Overview</a></li><li class="chapter-item expanded "><a href="quickstart/development_status.html"><strong aria-hidden="true">2.2.</strong> Development Status</a></li><li class="chapter-item expanded "><a href="quickstart/getting_started.html"><strong aria-hidden="true">2.3.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="quickstart/data_spaces.html"><strong aria-hidden="true">2.4.</strong> Data Spaces</a></li><li class="chapter-item expanded "><a href="quickstart/data_assets.html"><strong aria-hidden="true">2.5.</strong> Adding and Retrieving Data</a></li><li class="chapter-item expanded "><a href="quickstart/storage.html"><strong aria-hidden="true">2.6.</strong> Storage System</a></li><li class="chapter-item expanded "><a href="quickstart/proxy.html"><strong aria-hidden="true">2.7.</strong> Proxy Nodes</a></li><li class="chapter-item expanded "><a href="quickstart/governance_moderation.html"><strong aria-hidden="true">2.8.</strong> Governance and Moderation</a></li></ol></li><li class="chapter-item expanded "><a href="developers.html"><strong aria-hidden="true">3.</strong> Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pallets.html"><strong aria-hidden="true">3.1.</strong> Pallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pallets/pallets_iris_assets.html"><strong aria-hidden="true">3.1.1.</strong> Iris-Assets</a></li><li class="chapter-item expanded "><a href="pallets/pallets_iris_session.html"><strong aria-hidden="true">3.1.2.</strong> Iris-Session</a></li><li class="chapter-item expanded "><a href="pallets/pallets_iris_ledger.html"><strong aria-hidden="true">3.1.3.</strong> Iris-Ledger</a></li><li class="chapter-item expanded "><a href="pallets/pallets_data_spaces.html"><strong aria-hidden="true">3.1.4.</strong> Data-Spaces</a></li></ol></li><li class="chapter-item expanded "><a href="contracts.html"><strong aria-hidden="true">3.2.</strong> Contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contracts/contracts_chain_extension.html"><strong aria-hidden="true">3.2.1.</strong> Chain Extension</a></li><li class="chapter-item expanded "><a href="contracts/composable_access_rules.html"><strong aria-hidden="true">3.2.2.</strong> Composable Access Rule and Rule Executor</a></li><li class="chapter-item expanded "><a href="contracts/contracts_asset_exchange.html"><strong aria-hidden="true">3.2.3.</strong> Iris Asset Exchange</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">4.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">iris</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the official documentation for <a href="https://github.com/ideal-lab5/iris">Iris</a>, developed and maintained by <a href="https://idealabs.network">ideal labs</a>.</p>
<p><code>This documentation and any information in it is subject to frequent and radical change as Iris is developed.</code></p>
<p><img src="./resources/web3_foundation_grants_badge_black.png" alt="sponsored by web3 foundation" /></p>
<p>Read our w3f grant proposal <a href="https://github.com/w3f/Grants-Program/blob/master/applications/iris.md">here</a></p>
<h2 id="what-is-iris"><a class="header" href="#what-is-iris">What is Iris?</a></h2>
<p>Iris is a <strong>decentralized data exchange protocol</strong> that enables a secure data ownership, access management, and delivery layer for Web 3.0 applications. It is infrastructure for the decentralized web. By building a cryptographically verifiable relationship between storage and ownership, Iris provides a data exchange which enables the transfer and monetization of access to and ownership of data across chains, smart contracts and participants in the network or connected through a relay chain. Iris provides security, reputation, and governance on top of storage, enabling data ownership, monetization, access management, capabilities to define unique business logic for data access and authorization, as well as smart contract support for content delivery. It applies DeFi concepts to data to represent off-chain assets in an on-chain context by representing data as a unique asset class with access to the underlying data controlled by ownership of assets minted from the asset class.</p>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>Iris functions by building a <strong>cryptographically verifiable relationship</strong> between data ownership, access, and availability. Data ownership is treated as an on-chain asset class, while access (equivalently, partial ownership) is granted by owning an asset minted from the asset class, subject to business logic as determined by the data owner (via <a href="./contracts/composable_access_rules.html">composable access rules</a>).</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Ownership and Access via Assets</strong>
<ul>
<li>Owned content in Iris is treated as a unique asset class</li>
<li>Access to content is synonymous with owning assets minted from the asset class. This allows us to easily transfer <em>access</em> to data across parachains and smart contracts.</li>
</ul>
</li>
<li><strong>Data Spaces</strong>
<ul>
<li>Data spaces act as unique, owned enclaves of data within the network. Any node can create their own data space, define who can associate their data with it, and further what kinds of data are allowed to exist within their space.</li>
</ul>
</li>
<li><strong>Unique Authorization and Access Models</strong>
<ul>
<li>Data owners can use rule executors and composable access rules to define unique authorization and access models for their data.</li>
</ul>
</li>
<li><strong>Configurable Storage System</strong>
<ul>
<li>Iris is capable of leveraging many different storage systems to meet user needs, including support for both centralized and decentralized storage solutions.</li>
</ul>
</li>
<li><strong>smart contract support</strong>
<ul>
<li>interact with the iris runtime through the <a href="./contracts_chain_extension.html">chain extension</a></li>
</ul>
</li>
<li><strong>Secure</strong>
<ul>
<li>Iris uses a <strong>threshold encryption</strong> mechanism to secure your data.</li>
</ul>
</li>
<li><strong>Social</strong>
<ul>
<li>Through an anonymous feedback and reputation system, data consumers can rate data owners, individual data, and data spaces.</li>
</ul>
</li>
<li><strong>Transparent Governance</strong>
<ul>
<li>In the future Iris will provide a robust governance framework that allows us to accomplish the same level of governance as major platform and service providers while maintaining decentralization and full transparency.</li>
</ul>
</li>
</ul>
<p>For a full breakdown of where we are in the implementation of these features, take a look at our <a href="./quickstart/development_status.html">roadmap</a>.</p>
<h2 id="vision"><a class="header" href="#vision">Vision</a></h2>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<ul>
<li>twitter: https://twitter.com/ideal_labs</li>
<li>website: https://idealabs.network/</li>
<li>email: driemworks@idealabs.network</li>
<li>discord: https://discord.gg/w8PF9MM6</li>
<li>github: github.com/ideal-lab5</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>Documentation on the inner workings of Iris and tutorials to get you up and running.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technical-overview"><a class="header" href="#technical-overview">Technical Overview</a></h1>
<h2 id="tech-stack"><a class="header" href="#tech-stack">Tech Stack</a></h2>
<h3 id="ipfs"><a class="header" href="#ipfs">IPFS</a></h3>
<p>Iris uses go-ipfs for our 'hot' storage system, which is supported by proxy nodes. This integration is currently unavailable in Iris, but will be coming soon.</p>
<h3 id="substrate"><a class="header" href="#substrate">Substrate</a></h3>
<p>Substrate is a blockchain framework built by parity. It provides the building blocks for creating a blockchain, including the database, consensus, rpc, and much more.</p>
<h3 id="react"><a class="header" href="#react">React</a></h3>
<p>We use react to build the user interface to interact with our node. We specifically rely on the <code>polkadotjs</code> and <code>ipfs-http-core</code> libraries.</p>
<h2 id="the-iris-runtime"><a class="header" href="#the-iris-runtime">The Iris Runtime</a></h2>
<p>Iris functions by embedding an IPFS node within the substrate runtime and allowing validator nodes to form a private IPFS network. By building a blockchain layer on top of the embedded storage, we are able to track calls and responses to IPFS on chain, allowing nodes to be rewarded for storing and retrieving data. Additionally, this allows us to represent offchain storage using on chain assets and to build a cryptographic relationship between data storage, ownership, and access.</p>
<p>The Iris runtime builds on exsiting modules within the Substrate runtime, specifically the session and assets modules. It is currently a proof of authority network. In general, the Iris-Assets module, which depends on the assets modules, provides data ingestion, and asset class management. The Iris-Session module enables session based storage for content owner, where storage is provided by network validators. Read more on the Iris-assets and Iris-Session modules <a href="quickstart/./pallets.html">here</a>.</p>
<p><img src="quickstart/../resources/runtime_modules.png" alt="runtime modules" /></p>
<h3 id="node-types"><a class="header" href="#node-types">Node Types</a></h3>
<p>There are several node types within Iris, each with their own distinct capabilities:</p>
<ol>
<li>Data owner</li>
<li>Data consumer</li>
<li><a href="quickstart/./validators.html">Validator</a></li>
<li><a href="quickstart/./proxy.html">proxy Node</a></li>
</ol>
<p>In the future another role will be created for moderation and governance capabilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-status"><a class="header" href="#development-status">Development Status</a></h1>
<p>We plan to approach development over four distinct phase in order to iteratively implement Iris.</p>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<p><img src="quickstart/../resources/roadmap.png" alt="roadmap" /></p>
<h2 id="phases"><a class="header" href="#phases">Phases</a></h2>
<p>Here we detail the phases and explain where we currently are. The final intended state is as outline in our whitepaper draft, available at: <a href="https://www.idealabs.network/docs">www.idealabs.network/docs</a></p>
<h3 id="phase-0"><a class="header" href="#phase-0">Phase 0</a></h3>
<p><strong>COMPLETE</strong></p>
<p>Phase 0 delivered the basis of the iris blockchain, as detailed in the original <a href="https://github.com/w3f/Grants-Program/blob/master/applications/iris.md">Iris grant proposal</a>. Specifically, it delivered the mechanism for creating a cryptographic relationship between ownership, storage, and access. In a way, this can be thought of as a semi-decentralized (since it is a PoA network) IPFS pinnings service with an ownerhsip layer built on top of it. Further, this initial phase delivered the ability to use smart contracts to interact with the Iris runtime (via a chain extension). For more in depth details ,see the grant proposal. This phase also delivered a simple react-based user interface built on top of polkadotjs.</p>
<h3 id="phase-1"><a class="header" href="#phase-1">Phase 1</a></h3>
<p><strong>IN PROGRESS</strong></p>
<p>We intend to complete this phase by Q3 2022.</p>
<p>This phase, which is currently undergoing review by the w3f grants team, builds on the initial phase to set Iris up for long term success.</p>
<p>The intention of this phase is to implement several features that enable Iris to be a secure, social, and highly-available storage network without compromising decentralization. In our system, data owners associate their data with any number of 'data spaces' which each have specific rule sets and inclusion policies. We also lay the foundations for our encryption scheme (we will use a threshold encryption mechanism, though the implementation of this is out of scope for this proposal) by introducing the concept of the proxy node which will act as the linchpin for re-encryption in the future, as well as allows data owners and data consumers to run light clients (as they no longer are required to run the full node and add data to the embedded IPFS node). We also introduce a game-theoretic framework for ensuring replication and availability of data within the storage layer of Iris. Additionally we introduce &quot;composable access rules&quot;, which allow data owners to specify rules which are implicitly enforced when consumers access their data. Lastly, we will build a javascript SDK to allow user interfaces for dapps built on Iris to easily build applications and interface with Iris.</p>
<p>To summarize, in the following we propose:</p>
<ul>
<li>the introduction of &quot;data spaces&quot;</li>
<li>the implementation of &quot;composable access rules&quot; to apply custom business logic to data</li>
<li>the introduction of &quot;proxy nodes&quot; that enable threshold encryption within the network</li>
<li>the implementation of an availability-encouraging storage system</li>
<li>a javascript SDK to allow dapp developers to easily build front ends for smart contracts on Iris, iris.js</li>
</ul>
<h3 id="phase-2"><a class="header" href="#phase-2">Phase 2</a></h3>
<p>Phase 2 will enable:</p>
<ul>
<li>threshold encryption</li>
<li>anonymous repoutation system</li>
</ul>
<h3 id="phase-3"><a class="header" href="#phase-3">Phase 3</a></h3>
<p>Phase 4 enables moderation and curation within Iris. We expect that we can go live prior to the completion of this phase.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ol>
<li><a href="quickstart/getting_started.html#installation">Installation</a></li>
<li><a href="quickstart/getting_started.html#running">Running</a></li>
<li><a href="quickstart/getting_started.html#interacting-with-your-node">Interacting with your Node</a></li>
<li><a href="quickstart/getting_started.html#testing">Testing</a></li>
</ol>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>There are three ways to install iris, either building the source code, building a docker image, or simply installing from docker.</p>
<h3 id="build-from-sources"><a class="header" href="#build-from-sources">Build from Sources</a></h3>
<pre><code class="language-bash">git clone https://github.com/ideal-lab5/iris.git
cd iris
cargo +nightly build --release
</code></pre>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>Install from the docker hub
<code>docker pull ideallabs/iris</code></p>
<p><strong>OR</strong></p>
<p>From the latest sources, build the docker image:
<code>docker build -t ideallabs/iris -f /Dockerfile .</code></p>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<h3 id="from-sources"><a class="header" href="#from-sources">From Sources</a></h3>
<pre><code class="language-bash"># purge the local chain data
./target/release/node-template purge-chain --base-path /tmp/alice --dev -y
# run the build
./target/release/iris-node \
  --base-path /tmp/alice \
  --dev \
  --alice \
  --port 30333 \
  --ws-port 9944 \
  --rpc-port 9933 \
  --rpc-cors all \
  --ws-external \
  --rpc-external \
  --rpc-methods=unsafe
</code></pre>
<p>Note: to specify a bootnode, use the bootnodes parameter. ex: <code>--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEdUQFXhAF4fu9hqRTWqsigioyjatRKRZ7mwyQCBoWyK3</code></p>
<h3 id="from-docker"><a class="header" href="#from-docker">From Docker</a></h3>
<pre><code class="language-bash">docker run -p 9944:9944 \
  -p 9933:9933 \
  -p 30333:30333 \
  -p 9615:9615 \
  -it \
  --rm \
  --name iris-alice \
  ideallabs/iris \
  --dev --ws-external --rpc-external \
  --node-key 0000000000000000000000000000000000000000000000000000000000000001
</code></pre>
<h2 id="interacting-with-your-node"><a class="header" href="#interacting-with-your-node">Interacting with your node</a></h2>
<p><em>See the <a href="quickstart/./tech_overview.html">tech overview</a> for information on extrinsics, our tech stack, and more.</em></p>
<h3 id="polkadotjs"><a class="header" href="#polkadotjs">PolkadotJs</a></h3>
<p>As the UI undergoes development, the most <em>stable</em> way to interact with your node is to use the default <a href="https://polkadot.js.org/">polkadotjs ui</a>.</p>
<h3 id="the-iris-ui"><a class="header" href="#the-iris-ui">The Iris UI</a></h3>
<p>The Iris UI provides a mechanism to add and retrieve data from Iris, to create an asset class, mint assets, privision data access, and manage both asset classes and assets.</p>
<p>If you intend to add data to Iris, you must also run an IPFS node locally. This holds for running from sources as well as the docker image. Run IPFS with <code>ipfs daemon</code>.</p>
<h3 id="running-from-sources"><a class="header" href="#running-from-sources">Running from Sources</a></h3>
<pre><code class="language-bash">git clone https://github.com/ideal-lab5/ui.git
cd ui
npm i
npm start
</code></pre>
<h3 id="running-from-docker"><a class="header" href="#running-from-docker">Running from Docker</a></h3>
<pre><code class="language-bash">docker pull ideallabs/iris-ui
docker run -it --rm -p 3000:3000 ideallabs/iris-ui
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Run the unit tests with <code>cargo +nightly test iris</code>.</p>
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<p>We aim for a minimum of 80% coverage on new code.</p>
<h2 id="manual-testing"><a class="header" href="#manual-testing">Manual Testing</a></h2>
<p>Our manual testing approach largely consists of invoking extrinsics and checking runtime storage. We do this using the polkadot UI:
https://polkadot.js.org/apps/</p>
<h3 id="useful-tools"><a class="header" href="#useful-tools">Useful Tools</a></h3>
<h4 id="calling-substrate-rpc-endpoints"><a class="header" href="#calling-substrate-rpc-endpoints">Calling substrate RPC endpoints</a></h4>
<p>To convert strings to hex, I like this tool:
https://onlinestringtools.com/convert-string-to-hexadecimal</p>
<h4 id="querying-substrate-storage"><a class="header" href="#querying-substrate-storage">Querying Substrate Storage</a></h4>
<p>https://www.shawntabrizi.com/substrate-js-utilities/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-spaces"><a class="header" href="#data-spaces">Data Spaces</a></h1>
<h2 id="what-is-a-data-space"><a class="header" href="#what-is-a-data-space">What is a data space?</a></h2>
<p>A data space is a user created and owned 'space' that data can be associated with. Data spaces allows nodes to group together disparate data sets based on ownership of the data asset classes that the data is associated with. A data space allows the owner to specify which nodes are authorized to associate data with their space. Data spaces form the basis for moderation within the network.</p>
<p>For example, a dapp developer may want all data added to iris that should be associated with their application to be both easily found within Iris and also subject to additional checks specific to their application, such as only allowing certain types of file extensions or moderating data in some specific way (more on this in the moderation and governance section). By creating their own data space, the owner can authorize users of their dapp to associate data with the space.</p>
<h2 id="creating-a-data-space"><a class="header" href="#creating-a-data-space">Creating a Data Space</a></h2>
<p>A data space is really an asset class mapped to a set of configuration items.</p>
<h2 id="granting-access"><a class="header" href="#granting-access">Granting access</a></h2>
<p>To grant access to your data space to another address in the network, mint new assets from the asset class and assign them to the given address. This can be done in several different ways with varying degress of control over how the holder of the asset can associate their own data assets the data space. In general, either the owner of the asset class can:</p>
<ul>
<li>lock transfers of the asset, meaning the holder cannot transfer it to any other accounts</li>
<li>retain rights to revoke the asset, meaning the data space administrator can block previously authorized users</li>
</ul>
<p><img src="quickstart/../../resources/data_spaces.png" alt="data spaces" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-assets"><a class="header" href="#data-assets">Data Assets</a></h1>
<p>Data assets form the core cryptographic relationship between data storage, access, and ownership.</p>
<h2 id="adding-data-and-creating-asset-classes"><a class="header" href="#adding-data-and-creating-asset-classes">Adding data and Creating Asset Classes</a></h2>
<p>To add data to the network, a data owner must first run the <a href="quickstart/./offchain_client.html">offchain client</a> and there must be at least one available <a href="quickstart/./proxy.html">proxy node</a>. First, the desired data to be ingested is added to the offchain client. The data owner then invokes the <code>create</code> extrinsic from the <a href="quickstart/../pallets/pallets_iris_assets.html">iris-assets</a> pallet.</p>
<h3 id="adding-composable-access-rules"><a class="header" href="#adding-composable-access-rules">Adding Composable Access Rules</a></h3>
<p>* In progress *</p>
<h2 id="provisioning-data-access"><a class="header" href="#provisioning-data-access">Provisioning data access</a></h2>
<p>To provision access to data, an owner of a data asset class mints new assets from the asset class and distributes them to addresses who should be allowed access (this is the same approach used by granting access to <a href="quickstart/./data_spaces.html">data spaces</a>).</p>
<h2 id="retrieving-data"><a class="header" href="#retrieving-data">Retrieving data</a></h2>
<p>To retrieve data to the network, a data owner must first run the <a href="quickstart/./offchain_client.html">offchain client</a> and there must be at least one available <a href="quickstart/./proxy.html">proxy node</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p><em>currently under development - The storage system is not currently implemented</em>
Iris is capable of integrating with nearly any storage system, be it centralized or decentralized. We accomplish this through the use of a generic storage connector module.</p>
<h2 id="hot-storage"><a class="header" href="#hot-storage">Hot Storage</a></h2>
<p>Iris uses embedded instances of IPFS to enable hot-storage within the runtime. It runs a secondary runtime, which runs the ipfs daemon within proxy nodes, allowing them to add, remove, pin, and cat data, as well as share it with other nodes. Additionally, this enables Iris to use the full power of IPFS to deliver data to consumers.</p>
<h2 id="cold-storage"><a class="header" href="#cold-storage">Cold Storage</a></h2>
<p>Cold storage is configurable within Iris via the storage connector module. Iris allows for the storage connector to be developed to support nearly any storage system, centralized or decentralized.</p>
<p>In our local test environment we enable storage to a local server.</p>
<p>Once we deploy to Kusama, we will leverage Crust as our cold storage solution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxy"><a class="header" href="#proxy">Proxy</a></h1>
<p><em>currently under development - The proxy nodes are not currently implemented</em></p>
<p>Proxy nodes form the basis for ingestion and ejection of data from the Iris network. The act both as a gateway, which proxies calls to IPFS for data owners and data consumers, as well as power the threshold encryption that will be added to Iris in the future.</p>
<p><img src="quickstart/../../resources/proxy_overview.png" alt="proxy overview" /></p>
<h2 id="becoming-a-proxy-node"><a class="header" href="#becoming-a-proxy-node">Becoming a Proxy Node</a></h2>
<p>Becoming a proxy node functions similarly to becoming a validator node in a proof of stake consensus system. Additionally, proxy nodes must meet minimum hardware requirements. We enforce that they must both:</p>
<ul>
<li>run an intel processor (6th gen or greater) so that they can use intel SGX (this could possibly not be needed)</li>
<li>have minimum bandwidth of 50 mbps up/down</li>
</ul>
<p>As proxy nodes ultimately determine the bandwidth of the network, we require 50mbps to ensure an acceptable minimum network bandwidth.</p>
<h2 id="proxy-node-rewards"><a class="header" href="#proxy-node-rewards">Proxy node rewards</a></h2>
<p>Each time a node requests data ingestion and ejection to the network they are charged an additional transaction fee which will be used to reward proxy nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="governance-and-moderation"><a class="header" href="#governance-and-moderation">Governance and Moderation</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developers"><a class="header" href="#developers">Developers</a></h1>
<p>Information for developers to learn more about how iris works and how to develop apps on Iris.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pallets"><a class="header" href="#pallets">Pallets</a></h1>
<p>Iris provides several new pallets on top of those available by default in Substrate.</p>
<ol>
<li><a href="./pallets/pallet_iris_assets.html">Iris-Assets</a></li>
<li><a href="./pallets/pallet_iris_session.html">Iris-Session</a></li>
<li><a href="./pallets/pallet_iris_ledger.html">Iris-Ledger</a></li>
<li><a href="./pallets/pallets_data_spaces.html">Data Spaces</a></li>
<li>Iris-Storage: In development</li>
<li>Iris-Proxy: In development</li>
</ol>
<p><img src="./resources/runtime_modules.png" alt="runtime modules" />
<em>Completed and active modules are marked in purple, planned modules in yellow. Dependencies are represented as arrows</em></p>
<h2 id="data-spaces-1"><a class="header" href="#data-spaces-1">Data Spaces</a></h2>
<p>The <a href="./pallets/pallets_data_spaces.html">Data Spaces</a> pallet lets users define data spaces that data asset classes can be associated with.</p>
<h2 id="iris-assets"><a class="header" href="#iris-assets">Iris Assets</a></h2>
<p>The <a href="./pallets/pallet_iris_assets.html">Iris-Assets</a> pallet provides functionality for nodes to inject data into Iris, create and manage storage asset classes and to mint and burn assets.</p>
<h2 id="iris-session"><a class="header" href="#iris-session">Iris Session</a></h2>
<p>The <a href="./pallets/pallet_iris_session.html">Iris-Session</a> pallet provides session-based storage capabilities for network validators as well as enables ejecting data from the network. The iris-session palelt contains all functionality to interact with the embedded IPFS node. While a strict content-owner only node does not require the iris-session pallet, for both consumers and storage providers it is a necessity.</p>
<h2 id="iris-ledger"><a class="header" href="#iris-ledger">Iris Ledger</a></h2>
<p>The <a href="./pallets/pallets_iris_ledger.html">Iris-Ledger</a> pallet allows nodes to lock, unlock, and transfer native tokens.</p>
<h2 id="iris-storage"><a class="header" href="#iris-storage">Iris Storage</a></h2>
<p>A to-be-developed pallet which will enable the storage system.</p>
<h2 id="iris-proxy"><a class="header" href="#iris-proxy">Iris Proxy</a></h2>
<p>A to-be-developed pallet which will enable proxy node functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-assets-1"><a class="header" href="#iris-assets-1">Iris-Assets</a></h1>
<p>The iris-assets module relies on the <a href="https://github.com/paritytech/substrate/blob/master/frame/assets/README.md">assets module</a> available in Substrate. This pallet provides capabilities for content owners and content consumers. This module is entirely independent of IPFS. It provides capabilities to:</p>
<ul>
<li>inject data into the network</li>
<li>create and manage data asset classes</li>
<li>mint, transfer, and destroy assets</li>
</ul>
<p>The iris-assets module delivers data asset class and data asset management. This module appends commands to a DataQueue which are processed by validator nodes (see the <a href="pallets/./pallets_iris_session.html">iris-session</a> module for more info) in a module which implements logic for offchain workers to process commands in the DataQueue (in our case, the iris-session pallet).</p>
<h2 id="runtime-details"><a class="header" href="#runtime-details">Runtime Details</a></h2>
<h3 id="extrinsics"><a class="header" href="#extrinsics">Extrinsics</a></h3>
<p>Functions to inject data into the network and to create and manage asset classes and assets</p>
<ul>
<li><code>create</code></li>
<li><code>mint</code></li>
<li><code>burn</code></li>
<li><code>destroy</code></li>
<li><code>transfer_asset</code></li>
</ul>
<p>Functions that allow offchain workers to submit results from IPFS commands</p>
<ul>
<li><code>submit_ipfs_add_results</code></li>
</ul>
<h3 id="rpc"><a class="header" href="#rpc">RPC</a></h3>
<p>The iris-assets pallet contains the implementation of the RPC endpoint which fetches dat from the network. See more details <a href="pallets/./rpc.html">here</a>. The current implementation of this RPC endpoint will change drastically as we enter the next phase of development.</p>
<h3 id="data-ownership-as-asset-class-ownership"><a class="header" href="#data-ownership-as-asset-class-ownership">Data Ownership as Asset Class Ownership</a></h3>
<p>When a node adds data to Iris, the OCW that processes the request constructs a new asset class backed by some initial (user defined) amount of native currency. This results in a new <code>DataCommand</code> being added to the processing queue. When an OCW proceses the command and publishes results on chain, a new asset class is created. Asset creation and access is initiated in the iris-assets pallet but processed in the iris-session pallet.</p>
<p><img src="pallets/../resources/data_injection.drawio.png" alt="data-injection" /></p>
<p>Our initial use case makes assumptions that we will break in the future:</p>
<ol>
<li>There is an injective and surjective map between owner/cid and asset class.</li>
<li>Owning any non-zero quantity of assets in an asset class grants the owner access to the underlying data</li>
</ol>
<h3 id="accessing-data-via-minted-assets"><a class="header" href="#accessing-data-via-minted-assets">Accessing Data Via Minted Assets</a></h3>
<p><em>Disclaimer: The current approach that iris takes for retrieving data will undergo significant changes in the next phase of development.</em></p>
<h4 id="the-current-approach"><a class="header" href="#the-current-approach">The current approach</a></h4>
<p>To retrieve data, a node makes a request to Iris, adding a request to retrieve bytes to the queue. An OCW processes the command and adds the fetched content to local offchain storage. The node which requested the data can then invoke the <code>iris_retrieveBytes</code> RPC endpoint exposed on the node who fetched the content in order to retrieve it.</p>
<p>First, a node that owns some positive balance of an asset requests access to it. When this request is processed by the calling node's OCW, the OCW stores the data in offchain storage. When the RPC endpoint is invoked, the data is returned to the authorized caller in the response.</p>
<h4 id="the-next-phase-approach"><a class="header" href="#the-next-phase-approach">The next-phase approach</a></h4>
<p>In the next phase of development, we will use the <a href="pallets/../quickstart/offchain_client.html">offchain client</a> to retrieve data from the network, where a proxy node will stream the data to an authorized user. Additionally, composable access rules will be executed each time a node requests data from the network.</p>
<p><img src="pallets/../resources/data_ejection.drawio.png" alt="data-ejection" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-session-1"><a class="header" href="#iris-session-1">Iris-Session</a></h1>
<p>The Iris-session pallet incorporates both IPFS and the <a href="https://github.com/paritytech/substrate/blob/master/frame/session/README.md">session module</a> to allow network validators to provide storage for some existing asset class for the duration of a session. In general, it provides the capabilities to:</p>
<ul>
<li>provide storage to the network</li>
<li>capitalize on latent storage capacity</li>
<li>eject data from the network</li>
</ul>
<h2 id="runtime-details-1"><a class="header" href="#runtime-details-1">Runtime Details</a></h2>
<h3 id="interaction-with-embedded-ipfs"><a class="header" href="#interaction-with-embedded-ipfs">Interaction with Embedded IPFS</a></h3>
<p>The iris-session pallet contains the core logic for interacting with the embedded IPFS instance. In this module we expose the capability for offchain workers to process commands added to the DataQueue. Specifically, to:</p>
<ul>
<li>read IPFS public key and muiltiaddresses</li>
<li>add data to the IPFS by processing an AddBytes command</li>
<li>fetch data from IPFS by processing a CatBytes command</li>
<li>pin data to IPFS by processing a PinBytes command</li>
</ul>
<p>When a node adds an AddBytes command to the queue (via the iris-assets pallet), any other node is capable of processing the command and injecting the data into the network.</p>
<p>When a node adds a CatBytes command to the queue, it is uniquely processed by the calling node, adding the data to offchain storage so that it can be fetched via the RPC endpoint.</p>
<p>When a node adds a PinBytes command to the queue, it is uniquely processed by the calling node. The also results in the addition of the node to the <em>Pinners</em> storage map.</p>
<h3 id="session-based-approach-to-adding-validators"><a class="header" href="#session-based-approach-to-adding-validators">Session-based approach to adding validators</a></h3>
<p>Iris is a proof of authority network. Through the usage of the session pallet, we introduce a mechanism for an existing authority to add new validators to the network. Iris uses Aura for consensus and Grandpa for block finalization and there is no alteration to the default process through which nodes are rewarded.</p>
<p>In the long term, we intend to create a new consensus, which we are calling <code>Nominated Proof of Storage Capacity</code>. Details of this to come.</p>
<h3 id="session-based-approach-to-adding-and-rewarding-storage-providers"><a class="header" href="#session-based-approach-to-adding-and-rewarding-storage-providers">Session-based approach to adding and rewarding storage providers</a></h3>
<p><em>Note</em>: We currently follow a fairly naive scheme for incentivizing validators to store content. We intend to replace the below scheme with something much more mature in the future.</p>
<p>Validator nodes are a superset of the storage provider nodes. Validators, using the iris-session pallet, can request to store some owned content added to Iris. For example, if a node has added data and created a content asset class, then a validator node can request to store the content during the subsequent session.</p>
<p>There are three phases to each session:</p>
<ol>
<li>a pre-session planning phase</li>
<li>a session start phase</li>
<li>a session end phase</li>
</ol>
<p>When we say <strong>current session</strong> we mean a session that has been <em>planned</em>, and for which the possible storage providers are locked but not yet necessarily providing active storage. An <strong>active session</strong> is a session that has been <em>started</em> and for which the nodes are active storage providers. This is elaborated below:</p>
<ol>
<li>
<p>Pre-session planning: candidate storage providers that have pinned the CID they requested to store are added to a collection of active storage providers for that asset class for that session. The current session is incremented by one.</p>
</li>
<li>
<p>Session Start: The active session is incremented by one.</p>
</li>
<li>
<p>Session End: Validiators that have been storing data but have not accumulated any reward points for some preconfigured number of sessions (MaxDeadSessions) is removed from the validator pool.</p>
</li>
</ol>
<h3 id="reward-point-calculation"><a class="header" href="#reward-point-calculation">Reward Point Calculation</a></h3>
<p>Reward points are the interim rewards that storage providers receive for processing requests in the DataQueue. DataCommands are added to the DataQueue when:</p>
<ul>
<li>a content owner has requested to add data to Iris via the <code>create</code> extrinsic</li>
<li>successfully pinning data</li>
<li>a consumer has requested to fetch bytes from ipfs through the <code>retrieve_data</code> extrinsic.</li>
</ul>
<p>When data is requested from Iris, the underlying IPFS network will fetch the bytes from one of the storage providers (though it's possible it could exist in another node since we don't have much in terms of garbage collection in rust-ipfs). Though it may be possible to determine exactly which IPFS node the data was fetched from, this is most likely computationally expensive. We track the number of times some data was successfully requested (i.e. the number of times a consumer requested to fetch the content of an asset class of which they own an asset). At the end of the session, the total sum is distributed evenly to storage providers for that asset during the session.</p>
<p>Validators are rewarded for:</p>
<ul>
<li>Processing requests to inject data into IPFS (basically <code>ipfs add [cid]</code>)
<ul>
<li>Awarded 1 RP</li>
</ul>
</li>
<li>Pinning data to their embedded IPFS node (<code>ipfs pin [cid]</code>)
<ul>
<li>Awarded 1 RP</li>
</ul>
</li>
<li>Indirectly, when another node requests data they are providing storage for
<ul>
<li>The number of unallocated tokens for the session is incremented by 1</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-ledger-1"><a class="header" href="#iris-ledger-1">Iris-Ledger</a></h1>
<p>The ledger pallet is a utility pallet meant to facilitate locking and unlocking of funds to ensure existence of funds when buying and selling assets within the iris ecosystem.</p>
<h2 id="runtime-details-2"><a class="header" href="#runtime-details-2">Runtime Details</a></h2>
<h3 id="extrinsics-1"><a class="header" href="#extrinsics-1">Extrinsics</a></h3>
<ul>
<li><code>lock</code> - lock some amount of native tokens</li>
<li><code>unlock_and_transfer</code> - unlock the locked tokens and transfer all to some specified account</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-spaces-module"><a class="header" href="#data-spaces-module">Data Spaces Module</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The data-spaces module functions as a wrapper around the assets module. Dataspaces form the basis for both organizing disparate datasets within the network as well as for moderation (in the future). All data that exists within Iris must exist within the context of a dataspace.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-smart-contracts-on-iris"><a class="header" href="#building-smart-contracts-on-iris">Building smart contracts on iris</a></h1>
<p>Iris leverages the contracts module to allow users to deploy their own contracts to the iris blockchain. We enable developers to build dapps that take advantage of the iris runtime. In particular, Iris exposes a chain extension that provides functionality to call into the iris runtime from contracts deployed to the chain.</p>
<h2 id="dapps-on-iris"><a class="header" href="#dapps-on-iris">DApps on Iris</a></h2>
<h3 id="the-iris-asset-exchange"><a class="header" href="#the-iris-asset-exchange">The Iris Asset Exchange</a></h3>
<p>The first app built on Iris is an asset exchange to allow data owners to sell access to data consumers.</p>
<p><a href="./contracts_asset_exchange.html">Iris Asset Exchange</a></p>
<h3 id="developing-a-dapp"><a class="header" href="#developing-a-dapp">Developing a dapp</a></h3>
<h4 id="the-iris-chain-extension"><a class="header" href="#the-iris-chain-extension">The Iris Chain extension</a></h4>
<p><a href="./contracts_chain_extension.html">chain extension</a></p>
<h3 id="deploying-a-dapp"><a class="header" href="#deploying-a-dapp">Deploying a dapp</a></h3>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chain-extension"><a class="header" href="#chain-extension">Chain Extension</a></h1>
<p>The iris chain extension provides functionality for dapp developers to hook into the iris runtime. More specifically, it exposes the ability to call extrinsics from the iris-assets pallet and the iris-ledger pallet to enable developers to manage assets via mint and transfer abilities and to lock, unlock, and transfer tokens to other accounts.</p>
<h2 id="exposed-functions"><a class="header" href="#exposed-functions">Exposed Functions</a></h2>
<h3 id="from-the-iris-assets-pallet"><a class="header" href="#from-the-iris-assets-pallet">From the Iris-Assets pallet</a></h3>
<p>See the <a href="contracts/./pallets_iris_assets.html">iris-assets</a> for more details.</p>
<ul>
<li>create</li>
<li>request bytes</li>
<li>mint</li>
<li>transfer_assets</li>
</ul>
<h2 id="from-the-iris-ledger-pallet"><a class="header" href="#from-the-iris-ledger-pallet">From the Iris-Ledger pallet</a></h2>
<p>See the <a href="contracts/./pallets_iris_ledger.html">iris-ledger</a> for more details.</p>
<ul>
<li>lock_currency</li>
<li>unlock_and_transfer_currency</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To functions from the chain extension in your smart contract, register the chain extension:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink::chain_extension]
pub trait Iris {
    type ErrorCode = IrisErr;

    #[ink(extension = 0, returns_result = false)]
    fn transfer_asset(
        contract_account: ink_env::AccountId, 
        consumer_account: ink_env::AccountId, 
        asset_id: u32, 
        asset_quantity: u64
    ) -&gt; [u8; 32];

    #[ink(extension = 1, returns_result = false)]
    fn mint(caller: ink_env::AccountId, target: ink_env::AccountId, asset_id: u32, amount: u64) -&gt; [u8; 32];

    #[ink(extension = 2, returns_result = false)]
    fn lock(amount: u64) -&gt; [u8; 32];

    #[ink(extension = 3, returns_result = false)]
    fn unlock_and_transfer(target: ink_env::AccountId) -&gt; [u8; 32];
} 
<span class="boring">}
</span></code></pre></pre>
<p>and invoke the chain extension function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> self.env()
    .extension()
    .mint(
        caller, self.env().account_id(), asset_id, amount,
    ).map_err(|_| {}).ok();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composable-access-rules-and-rule-executors"><a class="header" href="#composable-access-rules-and-rule-executors">Composable Access Rules and Rule Executors</a></h1>
<p>A <strong>composable access rule</strong> is a smart contract that allows data owners to define and specify unique business models which are executed when a consumer nodes attempts to fetch it from the network. Compo9sable access rules are executed within the context of a <strong>rule executor</strong> contract.</p>
<p>A <strong>rule executor</strong> allows a data owner to determine a unique collection of rules that shall be executed in order to provide authorization to data consumers to access their data. At a basic level, a rule executor makes cross contract calls to each composable access rule and then uses the <code>submit_execution_results</code> function exposed from our chain extension to report the results back on chain, which feeds into the locking mechanism managed by the <a href="contracts/../pallets/pallets_iris_ejection.html">iris-ejection pallet</a>.</p>
<h2 id="how"><a class="header" href="#how">How?</a></h2>
<p>All composable access rules are smart contracts which impement the ComposableAccessRule trait. In particular, each rule implements the function:</p>
<ul>
<li><code>execute(asset_id, consumer_address) -&gt; bool</code>: Execute the logic that determines if the consumer can or cannot access the data associated with the asset id.</li>
</ul>
<p>A developer can then create their own rule executor, which instantiates the composable access rules that they want to execute and makes cross contract calls to get their results. A composable access rule contract can be simultaneously used by many rule executors. Finally, the <code>register_rule</code> extrinsic in the <a href="contracts/../pallets/pallets_iris_ejection.html">iris-ejection pallet</a> allows the owner of an asset class to register a rule executor with their asset class, by supplying the rule executor's address and the asset id as parameters.</p>
<h2 id="available-rules"><a class="header" href="#available-rules">Available Rules</a></h2>
<p>We are in the process of developing several contracts that will be available in Iris. We intend to allows developers to deploy their own contracts as well. </p>
<p>Composable Access Rules can be found in the <a href="https://github.com/ideal-lab5/contracts/tree/main/composable_access_rules">contracts</a> repository</p>
<p>For now, we only have a single pre-defined rule available:</p>
<h3 id="limited-use-rule"><a class="header" href="#limited-use-rule">Limited Use Rule</a></h3>
<p>The limited use rule contract specifies some number of times N that a consumer can use their asset to access the data.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>For an example rule executor, take a look at the <a href="https://github.com/ideal-lab5/contracts/tree/main/composable_access_rules/rule_executor">contracts</a> repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-asset-exchange"><a class="header" href="#iris-asset-exchange">Iris Asset Exchange</a></h1>
<p>The Iris Asset Exchange is a decentralized exchange to facilitate the buying and selling of assets in Iris.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>The source code and README for the IAE is located <a href="https://github.com/ideal-labs/contracts/tree/main/iris_asset_exchange">here</a>.</p>
<p>The iris-ui exposes a user interface to interact with the contract.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="publish_token_sale"><a class="header" href="#publish_token_sale">publish_token_sale</a></h3>
<p>Mint new tokens and gives ownership of them to the contract account. The owner specifies a static price that consumers pay in order to purchase the asset.</p>
<p>Parameters:</p>
<ul>
<li>asset_id: The id of some owned asset</li>
<li>quantity: The quanity of assets to mint and transfer to the contract</li>
<li>price: The price per minted asset</li>
</ul>
<h3 id="purchase_tokens"><a class="header" href="#purchase_tokens">purchase_tokens</a></h3>
<ol>
<li>lock price*amount tokens</li>
<li>transfer tokens to the caller (from the contract account)</li>
<li>unlock tokens</li>
<li>caller transfer tokens to the owner</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>asset</li>
<li>asset class</li>
<li>cid</li>
<li>data space</li>
<li>ipfs</li>
<li>multiaddress</li>
<li>substrate</li>
<li>wasm</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
