<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>iris</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Technical Overview</a></li><li class="chapter-item expanded "><a href="pallets.html"><strong aria-hidden="true">4.</strong> Pallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pallets_iris_assets.html"><strong aria-hidden="true">4.1.</strong> Iris-Assets</a></li><li class="chapter-item expanded "><a href="pallets_iris_session.html"><strong aria-hidden="true">4.2.</strong> Iris-Session</a></li></ol></li><li class="chapter-item expanded "><a href="rpc.html"><strong aria-hidden="true">5.</strong> RPC Endpoint Implementation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">iris</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the official documentation for <a href="https://github.com/iridium-labs/substrate/tree/iris">Iris</a>.</p>
<p><code>This documentation and any information in it is subject to frequent and radical change as Iris is developed.</code></p>
<p><img src="./resources/web3_foundation_grants_badge_black.png" alt="sponsored by web3 foundation" /></p>
<p>Read our initial web3 grant proposal <a href="https://github.com/w3f/Grants-Program/blob/master/applications/iris.md">here</a></p>
<h2 id="what-is-iris"><a class="header" href="#what-is-iris">What is Iris?</a></h2>
<p>Iris is a decentralized storage network that acts as a secure storage layer for Web 3.0. It is <strong>infrastructure for the decentralized web</strong> by providing a decentralized storage layer that can be leveraged by parachains and smart contracts in the Polkadot/Kusama ecosystem, allowing access to content to be transferred across chains and monetized. It provides indexability, security, availability, and governance on top of IPFS, enabling data ownership, access management, and the commodification of latent storage capacity and content delivery. Built with IPFS and Substrate, Iris can be used by parachains and smart contracts to create dapps that leverage private decentralized storage.</p>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>Iris functions by embedding an IPFS node in the Substrate runtime, allowing us to encode the DHT status on-chain.</p>
<p>Owned data is treated as a unique asset class within the blockchain, while access to the data is controlled by an asset minted from the asset class. Accounts that hold a positive balance of an asset are authorized to access the underlying content that the asset class is associated with. Iris will also have the capability to transfer assets between parachains and smart contracts, enabling a novel way to access data across the web.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Transparent Governance</strong>
<ul>
<li>In the future Iris will provide a robust governance framework that allows us to accomplish the same level of governance as major platform and service providers while maintaining decentralization and full transparency.</li>
<li>Data ownership and access to the data is completely transparent. Unlike centralized storage providers, data in Iris can never be removed by an external party (e.g. Iridium Industries) and instead can only be forcefully removed as a result of onchain governance.</li>
</ul>
</li>
<li><strong>Ownership and Access via Assets</strong>
<ul>
<li>Owned content in Iris is treated as a unique asset class</li>
<li>Access to content is synonymous with owning assets minted from the asset class. This allows us to easily transfer <em>access</em> to data across parachains and smart contracts.</li>
</ul>
</li>
<li><strong>Storage</strong>
<ul>
<li>Validator nodes monetize their latent storage capacity by providing storage to the network.</li>
</ul>
</li>
</ul>
<h2 id="vision"><a class="header" href="#vision">Vision</a></h2>
<p>Iris’ goal is to be a general cross chain storage layer for parachains, smart contracts, or parathreads in the polkadot and kusama ecosystems.</p>
<p>The initial motivation of Iris is to solve the “streaming problem”: As the number of streaming services with exclusive rights to content increases, the actual content to which consumers have access diminishes due to the arbitrary cloistering of content. In a decentralized approach, individual content owners can retain ownership of their content while doing away with a subscription based model. However, Iris may facilitate a plethora of applications whose scope is far beyond streaming.</p>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<ul>
<li>twitter: https://twitter.com/Iridium_labs</li>
<li>website: http://iridium.industries/</li>
<li>email: driemworks@iridium.industries</li>
<li>discord: https://discord.gg/w8PF9MM6</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ol>
<li><a href="chapter_2.html#installation">Installation</a></li>
<li><a href="chapter_2.html#running">Running</a></li>
<li><a href="chapter_2.html#interacting-with-your-node">Interacting with your Node</a></li>
<li><a href="chapter_2.html#testing">Testing</a></li>
</ol>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>There are three ways to install iris, either building the source code, building a docker image, or simply installing from docker.</p>
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<pre><code>git clone https://github.com/iridium-labs/substrate.git
cd substrate
git checkout iris
cargo +nightly build --release
</code></pre>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>Install from the docker hub
<code>docker pull iridiumlabs/iris</code></p>
<p><strong>OR</strong></p>
<p>From the latest sources, build the docker image:
<code>docker build -t iridiumlabs/iris -f ./.maintain/Dockerfile .</code></p>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<h3 id="from-sources"><a class="header" href="#from-sources">From Sources</a></h3>
<pre><code># purge the local chain data
./target/release/node-template purge-chain --base-path /tmp/alice --dev -y
# run the build
./target/release/node-template \
  --base-path /tmp/alice \
  --dev \
  --alice \
  --port 30333 \
  --ws-port 9944 \
  --rpc-port 9933 \
  --rpc-cors all \
  --ws-external \
  --rpc-external \
  --rpc-methods=unsafe
</code></pre>
<p>Note: to specify a bootnode, use the bootnodes parameter. ex: <code>--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEdUQFXhAF4fu9hqRTWqsigioyjatRKRZ7mwyQCBoWyK3</code></p>
<h3 id="from-docker"><a class="header" href="#from-docker">From Docker</a></h3>
<pre><code>docker run -p 9944:9944 \
  -p 9933:9933 \
  -p 30333:30333 \
  -p 9615:9615 \
  -it \
  --rm \
  --name iris-alice \
  iridiumlabs/iris \
  --dev --ws-external --rpc-external \
  --node-key 0000000000000000000000000000000000000000000000000000000000000001
</code></pre>
<p><em>note: node-key is only needed if you want this node to be a bootnode</em></p>
<h1 id="interacting-with-your-node"><a class="header" href="#interacting-with-your-node">Interacting with your node</a></h1>
<p><em>See the <a href="../src/chapter_3.html">tech overview</a> for information on extrinsics, rpc, etc.</em></p>
<h2 id="polkadotjs"><a class="header" href="#polkadotjs">PolkadotJs</a></h2>
<p>As the UI undergoes development, the most <em>stable</em> way to interact with your node is to use the default <a href="https://polkadot.js.org/">polkadotjs ui</a>.</p>
<h2 id="the-iris-ui"><a class="header" href="#the-iris-ui">The Iris UI</a></h2>
<p>The Iris UI provides a mechanism to add and retrieve data from Iris, to create an asset class, mint assets, privision data access, and manage both asset classes and assets.</p>
<p>If you intend to add data to Iris, you must also run an IPFS node locally. This holds for running from sources as well as the docker image. Run IPFS with <code>ipfs daemon</code>.</p>
<h3 id="running-from-sources"><a class="header" href="#running-from-sources">Running from Sources</a></h3>
<pre><code>git clone https://github.com/iridium-labs/ui.git
cd ui
npm i
REACT_APP_IPV4=&lt;your ipv4&gt; npm start
</code></pre>
<h3 id="running-from-docker"><a class="header" href="#running-from-docker">Running from Docker</a></h3>
<pre><code>docker pull iridiumlabs/iris-ui
# replace w.x.y.z with your ip
docker run -it --rm -p 3000:3000 -e &quot;REACT_APP_IPV4=w.x.y.z&quot; iridiumlabs/iris-ui
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Run the unit tests with <code>cargo test</code>.</p>
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<p>We aim for a minimum of 80% coverage on new code.</p>
<h2 id="manual-testing"><a class="header" href="#manual-testing">Manual Testing</a></h2>
<p>Our manual testing approach largely consists of invoking extrinsics and checking runtime storage. We do this using the polkadot UI:
https://polkadot.js.org/apps/</p>
<h3 id="useful-tools"><a class="header" href="#useful-tools">Useful Tools</a></h3>
<h4 id="calling-substrate-rpc-endpoints"><a class="header" href="#calling-substrate-rpc-endpoints">Calling substrate RPC endpoints</a></h4>
<p>To convert strings to hex, I like this tool:
https://onlinestringtools.com/convert-string-to-hexadecimal</p>
<h4 id="querying-substrate-storage"><a class="header" href="#querying-substrate-storage">Querying Substrate Storage</a></h4>
<p>https://www.shawntabrizi.com/substrate-js-utilities/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technical-overview"><a class="header" href="#technical-overview">Technical Overview</a></h1>
<ol>
<li><a href="chapter_3.html#tech-stack">Tech Stack</a></li>
<li><a href="chapter_3.html#node-roles">Node Roles</a></li>
<li><a href="chapter_3.html#runtime">Runtime</a></li>
</ol>
<h2 id="tech-stack"><a class="header" href="#tech-stack">Tech Stack</a></h2>
<h3 id="ipfs"><a class="header" href="#ipfs">IPFS</a></h3>
<p>Our integration with <a href="https://github.com/rs-ipfs/rust-ipfs">rust-ipfs</a> is based on <a href="https://rs-ipfs.github.io/offchain-ipfs-manual/introduction.html">prior work</a>. The iridium-labs/substrate <a href="https://github.com/iridium-labs/substrate/tree/offchain_ipfs_v3">offchain_ipfs_v3</a> branch maintained in sync with the latest substrate master.</p>
<p>The ui we provide relies on a local IPFS instance to add data (iris does not). To add data through the UI you must first run an instance of IPFS locally (you don't need to run an IPFS if you want read only access).</p>
<h3 id="substrate"><a class="header" href="#substrate">Substrate</a></h3>
<p>Substrate is a blockchain framework built by parity. It provides the building blocks for creating a blockchain, including the database, consensus, rpc, and much more.</p>
<h3 id="react"><a class="header" href="#react">React</a></h3>
<p>We use react to build the user interface to interact with our node. We specifically rely on the <code>polkadotjs</code> and <code>ipfs-http-core</code> libraries.</p>
<h2 id="node-roles"><a class="header" href="#node-roles">Node Roles</a></h2>
<ul>
<li><strong>Storage Provider</strong>: The storage provider node's responsibility includes processing commands added to the queue by other nodes and submitting the results of the command on chain.</li>
<li><strong>Content Owner</strong>: A content owner is responsible for making data available in some external IPFS node and interacting with Iris to ingest and maintain access to it.</li>
<li><strong>Content Consumer</strong>: A content consumer is responsible for using owned tickets to access owned content.</li>
</ul>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>Iris is a proof of authority network. In the future we intend to migrate to a PoS network, but due to the current limitations of rust-ipfs we will use PoA.</p>
<p>The Iris runtime builds from exsiting modules within the Substrate runtime, specifically the session and assets modules. In general, the Iris-Assets module, which depends on the assets modules, provides data ingestion, and asset class management. The Iris-Session module enables session based storage for content owner, where storage is provided by network validators. Read more on the Iris-assets and Iris-Session modules <a href="./pallets.html">here</a>.</p>
<p><img src="./resources/runtime_modules.png" alt="runtime modules" /></p>
<p><em>The Iris runtime modules and dependencies</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pallets"><a class="header" href="#pallets">Pallets</a></h1>
<p>Iris provides two new pallets on top of those available by default in Substrate.</p>
<p><img src="./resources/runtime_modules.png" alt="runtime modules" />
<em>Modules unique to iris are marked in purple. Dependencies are represented as arrows</em></p>
<p>The <a href="./pallet_iris_assets.html">Iris-Assets</a> pallet provides functionality for nodes to inject data into Iris, create and manage storage asset classes and to mint and burn assets.</p>
<p>The <a href="./pallet_iris_session.html">Iris-Session</a> pallet provides session-based storage capabilities for network validators as well as enables ejecting data from the network. The iris-session palelt contains all functionality to interact with the embedded IPFS node. While a strict content-owner only node does not require the iris-session pallet, for both consumers and storage providers it is a necessity.</p>
<p>These two pallets work in tandem to provide full functionality to inject and eject data from Iris. Though we discuss both pallets in depth in their respective chapters, here we will lay out the way that the two pallets work together to inject data, create asset classes, and to eject data. In general, the iris-assets pallet is responsible for adding commands to the data queue and the iris-session pallet is responsible for executing commands in the data queue.</p>
<h2 id="data-ownership-as-asset-class-ownership"><a class="header" href="#data-ownership-as-asset-class-ownership">Data Ownership as Asset Class Ownership</a></h2>
<p>When a node adds data to Iris, the OCW that processes the request constructs a new asset class backed by some initial (user defined) amount of native currency (see the <code>create_storage_asset</code> <a href="./chapter_3.html">extrinsic</a>). This results in a new <code>DataCommand</code> being added to the processing queue. When an OCW proceses the command and publishes results on chain, a new asset class is created. Asset creation and access is initiated in the iris-assets pallet but processed in the iris-session pallet.</p>
<p><img src="./resources/data_ingestion.drawio.png" alt="data-ingestion" /></p>
<p>Our initial use case makes assumptions that we will break in the future:</p>
<ol>
<li>There is an injective and surjective map between owner/cid and asset class.</li>
<li>Owning any non-zero quantity of assets in an asset class grants the owner access to the underlying data</li>
</ol>
<h3 id="accessing-data-via-minted-assets"><a class="header" href="#accessing-data-via-minted-assets">Accessing Data Via Minted Assets</a></h3>
<p>To retrieve data, a node makes a request to Iris, adding a request to retrieve bytes to the queue. An OCW processes the command and adds the fetched content to local offchain storage. The node which requested the data can then invoke the <code>iris_retrieveBytes</code> RPC endpoint exposed on the node who fetched the content in order to retrieve it.</p>
<p>First, a node that owns some positive balance of an asset requests access to it. When this request is processed by the calling node's OCW, the OCW stores the data in offchain storage. When the RPC endpoint is invoked, the data is returned to the authorized caller in the response.</p>
<p><img src="./resources/data_ejection_p1.drawio.png" alt="data-ejection part 1" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-assets"><a class="header" href="#iris-assets">Iris-Assets</a></h1>
<p>The iris-assets module relies on the <a href="https://github.com/paritytech/substrate/blob/master/frame/assets/README.md">assets module</a> available in Substrate. This pallet provides capabilities for content owners and content consumers. This module is entirely independent of IPFS. It provides capabilities to:</p>
<ul>
<li>inject data into the network</li>
<li>create and manage storage asset classes</li>
<li>mint assets</li>
</ul>
<p>The iris-assets module delivers asset class and derived asset management. This module appends commands to a DataQueue which are processed by validator nodes (see the <a href="./pallets_iris_session.html">iris-session</a> module for more info) in a module which implements logic for offchain workers to process commands in the DataQueue (in our case, the iris-session pallet).</p>
<h2 id="runtime-details"><a class="header" href="#runtime-details">Runtime Details</a></h2>
<h3 id="content-as-an-asset-class"><a class="header" href="#content-as-an-asset-class">Content as an asset class</a></h3>
<p>Asset class creation is accomplished through the <code>create</code> extrinsic. The extrinsic writes to the DataQueue, adding an Addbytes command. This command is processed by validator nodes in the iris-session pallet</p>
<h3 id="access-via-assets"><a class="header" href="#access-via-assets">Access via Assets</a></h3>
<p>After a node has successfully created an asset class, they can mint assets from the asset class. Each asset is synonymous with access to the underlying content.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-session"><a class="header" href="#iris-session">Iris-Session</a></h1>
<p>The Iris-session pallet incorporates both IPFS and the <a href="https://github.com/paritytech/substrate/blob/master/frame/session/README.md">session module</a> to allow network validators to provide storage for some existing asset class for the duration of a session. In general, it provides the capabilities to:</p>
<ul>
<li>provide storage to the network</li>
<li>capitalize on latent storage capacity</li>
<li>eject data from the network</li>
</ul>
<h2 id="runtime-details-1"><a class="header" href="#runtime-details-1">Runtime Details</a></h2>
<h3 id="interaction-with-embedded-ipfs"><a class="header" href="#interaction-with-embedded-ipfs">Interaction with Embedded IPFS</a></h3>
<p>The iris-session pallet contains the core logic for interacting with the embedded IPFS instance. In this module we expose the capability for offchain workers to process commands added to the DataQueue. Specifically, to:</p>
<ul>
<li>read IPFS public key and muiltiaddresses</li>
<li>add data to the IPFS by processing an AddBytes command</li>
<li>fetch data from IPFS by processing a CatBytes command</li>
<li>pin data to IPFS by processing a PinBytes command</li>
</ul>
<p>When a node adds an AddBytes command to the queue (via the iris-assets pallet), any other node is capable of processing the command and injecting the data into the network.</p>
<p>When a node adds a CatBytes command to the queue, it is uniquely processed by the calling node, adding the data to offchain storage so that it can be fetched via the RPC endpoint.</p>
<p>When a node adds a PinBytes command to the queue, it is uniquely processed by the calling node. The also results in the addition of the node to the <em>Pinners</em> storage map.</p>
<h3 id="session-based-approach-to-adding-validators"><a class="header" href="#session-based-approach-to-adding-validators">Session-based approach to adding validators</a></h3>
<p>Iris is a proof of authority network. Through the usage of the session pallet, we introduce a mechanism for an existing authority to add new validators to the network. Iris uses Aura for consensus and Grandpa for block finalization and there is no alteration to the default process through which nodes are rewarded.</p>
<p>In the long term, we intend to create a new consensus, which we are calling <code>Nominated Proof of Storage Capacity</code>. Details of this to come.</p>
<h3 id="session-based-approach-to-adding-and-rewarding-storage-providers"><a class="header" href="#session-based-approach-to-adding-and-rewarding-storage-providers">Session-based approach to adding and rewarding storage providers</a></h3>
<p>Validator nodes are a superset of the storage provider nodes. Validators, using the iris-session pallet, can request to store some owned content added to Iris. For example, if a node has added data and created a content asset class, then a validator node can request to store the content during the subsequent session.</p>
<p>There are three phases to each session:</p>
<ol>
<li>a pre-session planning phase</li>
<li>a session start phase</li>
<li>a session end phase</li>
</ol>
<p>When we say <strong>current session</strong> we mean a session that has been <em>planned</em>, and for which the possible storage providers are locked but not yet necessarily providing active storage. An <strong>active session</strong> is a session that has been <em>started</em> and for which the nodes are active storage providers. This is elaborated below:</p>
<ol>
<li>
<p>Pre-session planning: candidate storage providers that have pinned the CID they requested to store are added to a collection of active storage providers for that asset class for that session. The current session is incremented by one.</p>
</li>
<li>
<p>Session Start: The active session is incremented by one.</p>
</li>
<li>
<p>Session End: Rewards are distributed to the participants during the session. Currently, this is manifested as &quot;reward points&quot; but will be OBOL (as calculated by reward points) in the future.</p>
</li>
</ol>
<h3 id="reward-point-calculation"><a class="header" href="#reward-point-calculation">Reward Point Calculation</a></h3>
<p>Reward points are the interim rewards that storage providers receive processing requests in the DataQueue. These scenarios are when a content owner has requested to add data to Iris via the <code>create</code> extrinsic, when successfully pinning data, when a consumer has requested to fetch bytes from ipfs through the <code>retrieve_data</code> extrinsic.</p>
<p>All nodes with sufficient storage process AddBytes requests.</p>
<p>When data is requested from Iris, the underlying IPFS network will fetch the bytes from one of the storage providers (though it's possible it could exist in another node since we don't have much in terms of garbage collection in rust-ipfs). Though it may be possible to determine exactly which IPFS node the data was fetched from, this is most likely computationally expensive. We track the number of times some data was successfully requested (i.e. the number of times a consumer requested to fetch the content of an asset class of which they own an asset). At the end of the session, the total sum is distributed evenly to storage providers for that asset during the session.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc"><a class="header" href="#rpc">RPC</a></h1>
<h2 id="spec"><a class="header" href="#spec">Spec</a></h2>
<ul>
<li><code>iris_retrieveBytes</code></li>
<li>Description: This RPC endpoint allows external origins to access data to which they have been granted access. The account id should be the account id of the caller node.</li>
<li>Parameters:
<ul>
<li>message: The CID to of the content to fetch encoded in hex</li>
</ul>
</li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>The RPC endpoint leverages the embedded IPFS node to fetch data from storage providers.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Assume that you have requested access to some CID: <code>QmVsbXUbr5JwUDibTBmmh224GhWy1FWguTbHb3DTU3ahTE</code>.
First, convert the CID to hex: <code>0x516d56736258556272354a775544696254426d6d6832323447685779314657677554624862334454553361685445</code></p>
<p>and use it as the <code>message</code> field value, passing empty bytes to the other fields.</p>
<p><code>curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d '{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: &quot;1&quot;, &quot;method&quot;: &quot;iris_retrieveBytes&quot;, &quot;params&quot;:  [&quot;0x516d56736258556272354a775544696254426d6d6832323447685779314657677554624862334454553361685445&quot;]}'</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
