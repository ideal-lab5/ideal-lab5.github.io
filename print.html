<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>etf-docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Etf</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="etf.html"><strong aria-hidden="true">2.2.</strong> Math</a></li><li class="chapter-item expanded "><a href="use_cases.html"><strong aria-hidden="true">2.3.</strong> Use Cases</a></li></ol></li><li class="chapter-item expanded "><a href="etf_monitor.html"><strong aria-hidden="true">3.</strong> Etf Monitor</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">etf-docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>EtF Network is a <a href="https://github.com/paritytech/substrate.git">Substrate</a>-based blockchain that utilizes identity-based encryption and zero knowledge proofs to enable &quot;encryption to the future.&quot; Encryption to the future, similar in idea to timelock encryption, uses a slot-based consensus system as a reference clock to which messages can be encrypted. Valid blocks authored in future slots contain the corresponding secret keys. The initial version of our network uses a fork of Aura to implement a PoA version of EtF.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ul>
<li>Learn about <a href="./architecture.html">how Etf works</a></li>
<li>See the <a href="./getting_started.html">getting started guide</a> for an in-depth guide on running your own node.</li>
</ul>
<h3 id="repos"><a class="header" href="#repos">Repos</a></h3>
<ul>
<li><a href="https://github.com/ideal-lab5/substrate/tree/milestone1">Etf Network</a> The implementation of etf consensus along with the etf pallet.</li>
<li><a href="https://github.com/ideal-lab5/etf-monitor">Etf Network Monitor</a> A simple React app using polkadotjs to decode block headers and display decoded slot secrets.</li>
</ul>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p>driemworks@idealabs.network
https://idealabs.network</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>These docs and the code for both etf-network and etf-monitor are licensed as GPlv3.0.</p>
<p>This project is sponsored by a <a href="https://github.com/ideal-lab5/Grants-Program/blob/master/applications/cryptex.md">web3 foundation grant</a>. The work presented here represents the first milestone of the grant.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<p>EtF Network is a substrate based blockchain. In general, all commands that work with the default CLI implemented in substrate are compatible with this blockchain.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p>To build the blockchain locally:</p>
<pre><code class="language-bash"># clone substrate and checkout milestone1 branch
git clone git@github.com:ideal-lab5/substrate.git
cd substrate
git checkout milestone1
# nightly build
cargo +nightly build --release
</code></pre>
<p>(Optional) Setup the <a href="./etf_monitor.html">Etf monitor tool</a></p>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p><strong>From Sources</strong>
As previously stated, all default substrate commands will work. For example, to run the blockchain in dev mode as Alice, use:</p>
<pre><code class="language-bash">./target/release/node-template --tmp --dev --alice
</code></pre>
<p><strong>From Docker</strong></p>
<p>The latest docker image can be found <a href="https://hub.docker.com/r/ideallabs/etf">here</a></p>
<pre><code class="language-bash"># pull the latest image
docker pull ideallabs/etf
# run the image
# the image accepts all substrate commands/flags
docker run -p 9944:9944 -it --rm --name etf-node-0 ideallabs/etf --unsafe-rpc-external --validator --dev --tmp
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">unit tests</a></h3>
<p><code>cargo +nightly test</code></p>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<p>First navigate to <code>/bin/node-template/node/</code> and build it with <code>cargo +nightly build --profile=production --features runtime-benchmarks</code></p>
<p>run benchmark tests with
<code> cargo test --package pallet-etf --features runtime-benchmarks</code></p>
<p>Once built, generate weights against the compiled runtime with:</p>
<pre><code class="language-bash"># list all benchmarks
./target/production/node-template benchmark pallet --chain dev --pallet &quot;*&quot; --extrinsic &quot;*&quot; --repeat 0
# benchmark the etf pallet
./target/production/node-template benchmark pallet \
    --chain dev \
    --wasm-execution=compiled \
    --pallet pallet_etf \
    --extrinsic &quot;*&quot; \
    --steps 50 \
    --repeat 20 \
    --output bin/node-template/pallets/etf/src/weight.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="etf-network-overview-and-architecture"><a class="header" href="#etf-network-overview-and-architecture">EtF Network Overview and Architecture</a></h1>
<p>ETF network is based on Aura consensus, a round-robin PoA (Proof of Authority) slot-based consensus mechanism. It utilizes DLEQ (Discrete Logarithm Equality) proofs to create BLS (Boneh-Lynn-Shacham) IBE (Identity-Based Encryption) block seals. Block importers verify the validity of the DLEQ proof when importing each block.</p>
<p>We also introduce the EtF pallet, which stores public parameters for the identity based encryption scheme. The pallet uses arkworks to ensure parameters stored in the runtime are decodable as valid group elements.</p>
<p>The AuraAPI has been enhanced to deliver IBE parameters and secret keys to both block proposers and block verifiers, facilitating a more efficient and secure block proposal and verification process.</p>
<h2 id="pallets"><a class="header" href="#pallets">Pallets</a></h2>
<p><img src="./assets/pallets_overview_architecture.png" alt="pallets overview" /></p>
<h2 id="encryption-to-the-future"><a class="header" href="#encryption-to-the-future">Encryption to the Future</a></h2>
<p>Here we present a high-level overview of how EtF works. For a more in depth look, jump to the <a href="./etf.html">math</a></p>
<p>The initial version of the network uses a fork of Aura, a round-robin proof of authority consensus mechanism. Each authority knows the same secret, the IBE master secret which makes the identity based encryption scheme work (more on this <a href="">here</a>). They are trusted to act as a secret key custodian (a requirement we will relax in the future).  When a slot author proposes a block, they first use the master secret to calculate a slot secret, which they add to the block header. This slot secret is intended to be <strong>leaked</strong> and made public. Next, in order to ensure the correctness of the secret to be leaked, block producers include a DLEQ proof that shows the slot secret was correctly calculated. Along with this, they also sign the block as usual. </p>
<p>Block importers simply fetch the public IBE parameters from the EtF pallet and use it to verify the DLEQ proof. If the DLEQ proof is not valid, the block is rejected. </p>
<p><img src="./assets/high_level_flow_of_data.drawio.png" alt="high-level" /></p>
<h3 id="slot-identity"><a class="header" href="#slot-identity">Slot Identity</a></h3>
<p>We use a PoA consensus system in which a known set of authorities, say A = {A_1, …, A_n}, are selected as slot authors sequentially (round robin). That is, for a slot \(sl_k\), the authority to author a block in the slot is given by \(A_{sl_k} = A[sl_k \mod |A|] \). A slot’s identity is given by \(ID_{sl_k} = A_{sl_k} || sl_k\) where \(||\) is concatenation. That is, it’s the combination of the slot author’s public key and the slot id. For example, given the ss58 address <code>5GGrFp7o5b5CMSi9uZnkveRusegbVgVUa5BvqXRQHsJ9SSjc</code> (Alice), a slot identity might look like: <code>0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d231922012</code> 231922012 is the slot id and <code>0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d</code> is the public key of the ss58 address.</p>
<p>Our implementation works over curve BLS12-381. To get a public key from the slot id, we use a hash-to-G1 function, which gives us public keys in G1 (the elliptic curve group we’re working with). That is, each slot implicitly has an identity, and by evaluating the id under the hash-to-G1 function, a public key in G1. </p>
<h3 id="etf-pallet"><a class="header" href="#etf-pallet">ETF Pallet</a></h3>
<p>The ETF pallet stores public parameters needed for the IBE scheme, a single public key in G1 as a compressed byte array. This value is set on genesis and only changeable by the root user (via the Sudo pallet) when they call the <code>update_ibe_params</code> extrinsic. The extrinsic uses Arkworks to decode the input to ensure that the provided data is a valid element of G1, and if so then it encodes it in storage. In the future, we intend to make this a more democratic process.</p>
<p>The aura client reads the public parameters from the runtime while preparing the DLEQ proof (when claiming a slot)</p>
<h3 id="claiming-a-slot"><a class="header" href="#claiming-a-slot">Claiming a Slot</a></h3>
<p>When a block author claims a slot, they perform the <a href="./etf.html#identity-based-encryption">extract algorithm of the IBE scheme</a>, where they use their slot public key along with the master secret to calculate the slot secret (e.g. d = sQ where s is the master secret and  is the public key). In order to do this, we introduce new functionality to the existing AuraAPI which allows slot authors to fetch the IBE public parameters, which are stored in the etf pallet, as well as read the master secret from local storage. </p>
<p>After calculating the slot secret, the slot author is tasked with preparing a DLEQ proof that the slot secret was calculated from the master secret. We accomplish this by implementing a trait which enables DLEQ proof and verification, using Arkworks. It allows the prover to demonstrate that, given some xG and xH, that both were calculated from x without revealing the value.  In our scheme, one of the values is the slot secret, <code>d = sQ</code>, and the other is the master secret multiplied by the public param stored in the etf pallet. The DLEQ proof is then encoded within the block header when it is proposed by the author. That is, each block header contains a PreDigest which contains the slot id, the slot secret, and the DLEQ proof like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PreDigest: {
    slot: 'u64',
    secret: '[u8;48]',
    proof: '([u8;48], [u8;48], [u8;32], [u8;48])'
}
<span class="boring">}</span></code></pre></pre>
<h3 id="importing-and-verifying-blocks"><a class="header" href="#importing-and-verifying-blocks">Importing and Verifying Blocks</a></h3>
<p>When a block importer receives a new block, they first check that the slot is correct. If correct, then they recover the DLEQ proof from the block header and verify it along with the block seal (which is still a normal Schnorr signature). If the DLEQ proof is valid, then we know the slot secret is valid as well. If the proof is invalid, then the secret is incorrect and the block is rejected.</p>
<h3 id="consensus-error-types"><a class="header" href="#consensus-error-types">Consensus Error Types</a></h3>
<p>Block producers and importers are given two new consensus error types <a href="https://github.com/ideal-lab5/substrate/blob/502032949307b1c19cba606dbef1d2f108f71a56/primitives/consensus/common/src/error.rs#L53">here</a>. For <strong>block producers</strong>, the <code>InvalidIBESecret</code> is called when the aura client cannot fetch a master IBE secret from local storage. For <strong>block importers</strong>, <code>InvalidDLEQProof</code> is triggered when a DLEQ proof cannot be verified. This is very similar in functionality to the <code>BadSignature</code> error type.</p>
<h3 id="authority-incentives"><a class="header" href="#authority-incentives">Authority Incentives</a></h3>
<p>Since we have a proof of authority network, authority incentives are very simple.</p>
<ol>
<li>When a new session starts, <a href="https://github.com/ideal-lab5/substrate/blob/cf0a5193af80e458ee585a614f7ff12ece9b56fd/frame/aura/src/lib.rs#L269">each authority recieves 10 tokens</a></li>
<li>If an authority produces a bad block, it will be rejected by importers and the authority will be unable to author more blocks (this isn't completely implemented yet).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encryption-to-the-future-the-math"><a class="header" href="#encryption-to-the-future-the-math">Encryption to the Future (the math)</a></h1>
<p>The EtF network uses a slot-based consensus mechanism (Aura) and identity based encryption methods to associate an identity with each slot. The initial version of the network uses a simple approach for deriving keys, but which requires a significant amount of trust to be placed in each authority. Each authority is an IBE master secret key custodian and is made responsible for deriving and leaking IBE secret keys within each slot where they're an author. By encrypting to the public key associated with each slot, messages can be encrypted so that the decryption key is only made public when a block is authored in that slot.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>The encryption to the future (EtF) scheme consists of two PPT algorithms, \((Enc, Dec)\), such that:</p>
<ul>
<li>\( ct \leftarrow Enc(m, sl_k) \) for some future slot \(sl_k\) and a message \(m \in {0, 1}^*\). It outputs the ciphertext \(ct\).</li>
<li>\(m' \leftarrow Dec(ct, sk_{S_k})\) where \(sk_{S_k}\) is the secret key (as in the derive phase of the IBE scheme) leaked in the block authored in slot \(sl_k\).</li>
</ul>
<p>By using IBE and DLEQ proofs, slot winners calculate a proof of knowledge of the master secret along with the derived slot secret, which they include in each block header. Block importers validate the DLEQ proof when importing blocks, ensuring that secrets are only included when they are provably valid. </p>
<h3 id="identity-based-encryption"><a class="header" href="#identity-based-encryption">Identity Based Encryption</a></h3>
<p>EtF uses a flavor of the <a href="https://crypto.stanford.edu/~dabo/papers/bfibe.pdf">Boneh-Franklin IBE scheme</a>. In brief, identity based encryption is a scheme were a message can be encrypted for an arbitrary string, rather than some specific public key. For example, a message could be encrypted for &quot;bob@encryptme.com&quot; so that only the owner of the identity &quot;bob@encryptme.com&quot; is able to decrypt the message. The BF-IBE consists of four PPT algorithms (Setup, Extract, Encrypt, Decrypt). In brief, these can be defined as:</p>
<ul>
<li>\(Setup(1^\lambda) \to (pp, mk)\) where \(\lambda\) is the security parameter, \(pp\) is the output (system) params and \(mk\) is the master key.</li>
<li>\(Extract(mk, ID) \to sk_{ID}\) outputs the private key for \(ID\).</li>
<li>\(Encrypt(pp, ID, m) \to ct\) outputs the ciphertext \(ct\) for any message \(m \in {0, 1}^*\).</li>
<li>\(Decrypt(sk_{ID}, ct) \to m\) outputs the decrytped message \(m\)</li>
</ul>
<h3 id="dleq-proofs"><a class="header" href="#dleq-proofs">DLEQ Proofs</a></h3>
<p>EtF uses DLEQ proofs to verify the correctness of slot secrets without exposing the master secret for the IBE. In brief, the DLEQ proof allows a prover to construct a proof that two group elements were calculated from the same secret (e.g. xH and xG were calculated from the same x) without exposing the secret. Our scheme uses DLEQ proofs to leak an IBE slot secret \(d = sQ\) without exposing the master key, s.</p>
<p>The prover and verifier agree on two group generators, G and H and makes xG and xH publicly known. The goal is for the prover to demonstrate they know xG and xH were derived from the same x.</p>
<p>First, the prover:</p>
<ol>
<li>chooses a random \(r \in Z_p\) and calculates \(R1 = rG, R2 = rH\).</li>
<li>calculates the challenge value with a hash function \(c = H(R1, R2, xG, xH)\)</li>
<li>calculates the proof of knowledge \(s = r + c* x\)</li>
<li>shares \((R1, R2, s)\)</li>
</ol>
<p>With the agreed upon public parameters \(G, H\) and the proof \((R1, R2, s)\), a verifier can be convinced that the prover knows \(x\) without revealing it. The verifier:</p>
<ol>
<li>calculates the challenge value by hashing \(c = H(R1, R2, xG, xH)\)</li>
<li>checks if \(c(xG) - sG == R1 &amp;&amp; c(xH) - sH == R2\). If both equalities are true, the proof is valid. otherwise, it is invalid.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h1>
<p>Here we detail some use cases of EtF network at a high level. None of these currently exist and are only speculative, but this serves to showcase the networks capabilities.</p>
<h2 id="atomic-asset-swap"><a class="header" href="#atomic-asset-swap">Atomic Asset Swap</a></h2>
<p>Suppose there are two asset classes, A and B, and that Alice has <code>a</code> tokens of asset A and Bob has <code>b</code> tokens of asset B. Alice and Bob want to swap their assets, however, they do not trust each other. They both want to ensure that the asset swap only succeeds if both participants act honestly. We can accomplish this using the EtF network. First, recall that the network provides us the algorithms:</p>
<ul>
<li>\(ct \leftarrow E(m, sl_k)\) where \(m \in {0, 1}^*\) and \(sl_k\) is some future epoch</li>
<li>\(m \leftarrow D(ct, sk_k)\) where ct is the ciphertext and \(sk_k\) is the slot secret</li>
</ul>
<p>To perform the atomic asset swap, we’ll use a smart contract to act as intermediary holding of the assets. The protocol is as follows:</p>
<ol>
<li>Alice deposits <code>a</code> into the contract. Bob deposits <code>b</code> into the contract.</li>
<li>Alice prepares a transaction that calls a function in the contract, <code>execute</code>, which sends her locked tokens to Bob. She signs the transactions, then encrypts it for a future epoch and publishes the encrypted transaction and signature in the contract. </li>
<li>Bob does the same, submitting an encrypted transaction that sends his locked asset to Alice, encrypted for the same epoch as Alice’s transaction.</li>
<li>After the slot secret is revealed, both transactions can be decrypted and executed. Here, both transactions will call the contract <code>execute</code> function. The execute function checks if the other party provided a valid proof for their encrypted transaction, and if so, executes it. If the other party failed to submit a valid encrypted tx, then the swap fails and the offending party is slashed which the other receives all tokens back. </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="etf-monitor"><a class="header" href="#etf-monitor">Etf Monitor</a></h1>
<p>The etf monitor is a simple React app to monitor the etf network. Presently, it simply subscribes to incoming blocks and decodes the headers, displaying slot ids and slot secrets as new blocks are imported. At present, it is hardcoded to connect to a node's RPC on localhost:9944. This can be modified by updating the code and rebuilding. Enhancements will be coming soon.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Essentially, it simply decodes the predigest of each incoming slot header, which stores the slot id, secret, and DLEQ proof, and displays them in a table. </p>
<pre><code class="language-javascript">PreDigest: {
    slot: 'u64',
    secret: '[u8;48]',
    proof: '([u8;48], [u8;48], [u8;32], [u8;48])'
}
</code></pre>
<p><img src="./assets/etf_monitor.png" alt="etf-monitor" /></p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<pre><code class="language-bash">git clone git@github.com:ideal-lab5/etf-monitor.git
cd etf-monitor
npm i &amp;&amp; npm run start
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
