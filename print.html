<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>iris</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="tech_overview.html"><strong aria-hidden="true">3.</strong> Technical Overview</a></li><li class="chapter-item expanded "><a href="pallets.html"><strong aria-hidden="true">4.</strong> Pallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pallets_iris_assets.html"><strong aria-hidden="true">4.1.</strong> Iris-Assets</a></li><li class="chapter-item expanded "><a href="pallets_iris_session.html"><strong aria-hidden="true">4.2.</strong> Iris-Session</a></li><li class="chapter-item expanded "><a href="pallets_iris_ledger.html"><strong aria-hidden="true">4.3.</strong> Iris-Ledger</a></li></ol></li><li class="chapter-item expanded "><a href="rpc.html"><strong aria-hidden="true">5.</strong> RPC Endpoint Implementation</a></li><li class="chapter-item expanded "><a href="contracts.html"><strong aria-hidden="true">6.</strong> Contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contracts_chain_extension.html"><strong aria-hidden="true">6.1.</strong> Chain Extension</a></li><li class="chapter-item expanded "><a href="contracts_asset_exchange.html"><strong aria-hidden="true">6.2.</strong> Iris Asset Exchange</a></li></ol></li><li class="chapter-item expanded "><a href="governance_moderation.html"><strong aria-hidden="true">7.</strong> Governance and Moderation</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">8.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">iris</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the official documentation for <a href="https://github.com/ideal-labs/substrate/tree/iris">Iris</a>.</p>
<p><code>This documentation and any information in it is subject to frequent and radical change as Iris is developed.</code></p>
<p><img src="./resources/web3_foundation_grants_badge_black.png" alt="sponsored by web3 foundation" /></p>
<p>Read our w3f grant proposal <a href="https://github.com/w3f/Grants-Program/blob/master/applications/iris.md">here</a></p>
<h2 id="what-is-iris"><a class="header" href="#what-is-iris">What is Iris?</a></h2>
<p>Iris is a decentralized storage layer for Web 3.0. It is <strong>infrastructure for the decentralized web</strong>, providing a decentralized storage layer that can be leveraged by smart contracts and parachains, allowing access to content to be transferred across chains and monetized. It provides indexability, security, availability, and governance on top of IPFS, enabling data ownership, access management, and the commodification of latent storage capacity and content delivery. Built with IPFS and Substrate, Iris' dual network topology allows it to treat unique data as owned asset classes on the blockchain, while actual data is stored offchain in an IPFS network.</p>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>Iris functions by embedding an IPFS node in the Substrate runtime, allowing us to encode the DHT status on-chain.</p>
<p>Owned data is treated as a unique asset class within the blockchain, while access to the data is controlled by an asset minted from the asset class. Accounts that hold a positive balance of an asset are authorized to access the underlying content that the asset class is associated with. Iris will also have the capability to transfer assets between parachains and smart contracts, enabling a novel way to access data across the web.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Ownership and Access via Assets</strong>
<ul>
<li>Owned content in Iris is treated as a unique asset class</li>
<li>Access to content is synonymous with owning assets minted from the asset class. This allows us to easily transfer <em>access</em> to data across parachains and smart contracts.</li>
</ul>
</li>
<li><strong>Decentralized Storage</strong>
<ul>
<li>validator nodes can opt-in to provide storage to the network. Currently, this is only semi-decentralized while we are a proof of authority network, however we intend to transition to proof of storage capacity in the future.</li>
</ul>
</li>
<li><strong>smart contract support</strong>
<ul>
<li>interact with the iris runtime through the <a href="./contracts_chain_extension.html">chain extension</a></li>
</ul>
</li>
<li><strong>Transparent Governance</strong>
<ul>
<li>In the future Iris will provide a robust governance framework that allows us to accomplish the same level of governance as major platform and service providers while maintaining decentralization and full transparency.</li>
</ul>
</li>
</ul>
<h2 id="vision"><a class="header" href="#vision">Vision</a></h2>
<p>Iris aims to be a general decentralized storage layer for web3 applications, specifically in the kusama/polkadot ecosystems. Iris enables parachains, smart contracts, and parathreads to benefit from secure decentralized storage by taking advantage of XCM to transfer assets between chains.</p>
<p>We envision that Iris can facilitate a new variety of dapps that leverage decentralized storage, represented as asset classes, in a cross-chain, cross contract environment, where Iris can act as a common storage layer.</p>
<p>The initial motivation of Iris is to solve the “streaming problem”: As the number of streaming services with exclusive rights to content increases, the actual content to which consumers have access diminishes due to the arbitrary cloistering of content. In a decentralized approach, individual content owners can retain ownership of their content while doing away with a subscription based model. However, Iris may facilitate a plethora of applications whose scope is far beyond streaming.</p>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<ul>
<li>twitter: https://twitter.com/ideal_labs</li>
<li>website: http://idealabs.network/</li>
<li>email: driemworks@idealabs.network</li>
<li>discord: https://discord.gg/w8PF9MM6</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ol>
<li><a href="getting_started.html#installation">Installation</a></li>
<li><a href="getting_started.html#running">Running</a></li>
<li><a href="getting_started.html#interacting-with-your-node">Interacting with your Node</a></li>
<li><a href="getting_started.html#testing">Testing</a></li>
</ol>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>There are three ways to install iris, either building the source code, building a docker image, or simply installing from docker.</p>
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<pre><code>git clone https://github.com/ideal-labs/substrate.git
cd substrate
git checkout iris
cargo +nightly build --release
</code></pre>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>Install from the docker hub
<code>docker pull iridiumlabs/iris</code></p>
<p><strong>OR</strong></p>
<p>From the latest sources, build the docker image:
<code>docker build -t iridiumlabs/iris -f ./.maintain/Dockerfile .</code></p>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<h3 id="from-sources"><a class="header" href="#from-sources">From Sources</a></h3>
<pre><code class="language-bash"># purge the local chain data
./target/release/node-template purge-chain --base-path /tmp/alice --dev -y
# run the build
./target/release/node-template \
  --base-path /tmp/alice \
  --dev \
  --alice \
  --port 30333 \
  --ws-port 9944 \
  --rpc-port 9933 \
  --rpc-cors all \
  --ws-external \
  --rpc-external \
  --rpc-methods=unsafe
</code></pre>
<p>Note: to specify a bootnode, use the bootnodes parameter. ex: <code>--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEdUQFXhAF4fu9hqRTWqsigioyjatRKRZ7mwyQCBoWyK3</code></p>
<h3 id="from-docker"><a class="header" href="#from-docker">From Docker</a></h3>
<pre><code class="language-bash">docker run -p 9944:9944 \
  -p 9933:9933 \
  -p 30333:30333 \
  -p 9615:9615 \
  -it \
  --rm \
  --name iris-alice \
  iridiumlabs/iris \
  --dev --ws-external --rpc-external \
  --node-key 0000000000000000000000000000000000000000000000000000000000000001
</code></pre>
<p><em>note: node-key is only needed if you want this node to be a bootnode</em></p>
<h2 id="interacting-with-your-node"><a class="header" href="#interacting-with-your-node">Interacting with your node</a></h2>
<p><em>See the <a href="../src/chapter_3.html">tech overview</a> for information on extrinsics, rpc, etc.</em></p>
<h3 id="polkadotjs"><a class="header" href="#polkadotjs">PolkadotJs</a></h3>
<p>As the UI undergoes development, the most <em>stable</em> way to interact with your node is to use the default <a href="https://polkadot.js.org/">polkadotjs ui</a>.</p>
<h3 id="the-iris-ui"><a class="header" href="#the-iris-ui">The Iris UI</a></h3>
<p>The Iris UI provides a mechanism to add and retrieve data from Iris, to create an asset class, mint assets, privision data access, and manage both asset classes and assets.</p>
<p>If you intend to add data to Iris, you must also run an IPFS node locally. This holds for running from sources as well as the docker image. Run IPFS with <code>ipfs daemon</code>.</p>
<h3 id="running-from-sources"><a class="header" href="#running-from-sources">Running from Sources</a></h3>
<pre><code class="language-bash">git clone https://github.com/iridium-labs/ui.git
cd ui
npm i
REACT_APP_IPV4=&lt;your ipv4&gt; npm start
</code></pre>
<h3 id="running-from-docker"><a class="header" href="#running-from-docker">Running from Docker</a></h3>
<pre><code class="language-bash">docker pull iridiumlabs/iris-ui
# replace w.x.y.z with your ip
docker run -it --rm -p 3000:3000 -e &quot;REACT_APP_IPV4=w.x.y.z&quot; iridiumlabs/iris-ui
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Run the unit tests with <code>cargo test</code>.</p>
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<p>We aim for a minimum of 80% coverage on new code.</p>
<h2 id="manual-testing"><a class="header" href="#manual-testing">Manual Testing</a></h2>
<p>Our manual testing approach largely consists of invoking extrinsics and checking runtime storage. We do this using the polkadot UI:
https://polkadot.js.org/apps/</p>
<h3 id="useful-tools"><a class="header" href="#useful-tools">Useful Tools</a></h3>
<h4 id="calling-substrate-rpc-endpoints"><a class="header" href="#calling-substrate-rpc-endpoints">Calling substrate RPC endpoints</a></h4>
<p>To convert strings to hex, I like this tool:
https://onlinestringtools.com/convert-string-to-hexadecimal</p>
<h4 id="querying-substrate-storage"><a class="header" href="#querying-substrate-storage">Querying Substrate Storage</a></h4>
<p>https://www.shawntabrizi.com/substrate-js-utilities/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technical-overview"><a class="header" href="#technical-overview">Technical Overview</a></h1>
<ol>
<li><a href="tech_overview.html#tech-stack">Tech Stack</a></li>
<li><a href="tech_overview.html#the-iris-runtime">Runtime</a></li>
</ol>
<h2 id="tech-stack"><a class="header" href="#tech-stack">Tech Stack</a></h2>
<h3 id="ipfs"><a class="header" href="#ipfs">IPFS</a></h3>
<p>Our integration with <a href="https://github.com/rs-ipfs/rust-ipfs">rust-ipfs</a> is based on <a href="https://rs-ipfs.github.io/offchain-ipfs-manual/introduction.html">prior work</a>. The ideal-labs/substrate <a href="https://github.com/ideal-labs/substrate/tree/offchain_ipfs_v3">offchain_ipfs_v3</a> branch maintained in sync with the latest substrate master.</p>
<p>The ui we provide relies on a local IPFS instance to add data (iris does not). To add data through the UI you must first run an instance of IPFS locally (you don't need to run an IPFS if you want read only access).</p>
<h3 id="substrate"><a class="header" href="#substrate">Substrate</a></h3>
<p>Substrate is a blockchain framework built by parity. It provides the building blocks for creating a blockchain, including the database, consensus, rpc, and much more.</p>
<h3 id="react"><a class="header" href="#react">React</a></h3>
<p>We use react to build the user interface to interact with our node. We specifically rely on the <code>polkadotjs</code> and <code>ipfs-http-core</code> libraries.</p>
<h2 id="the-iris-runtime"><a class="header" href="#the-iris-runtime">The Iris Runtime</a></h2>
<p>Iris functions by embedding an IPFS node within the substrate runtime and allowing substrate nodes to form a private IPFS swarm. By building a blockchain layer on top of the embedded storage, we are able to track calls and responses to IPFS on chain, allowing nodes to be rewarded for storing and retrieving data.</p>
<p>The Iris runtime builds from exsiting modules within the Substrate runtime, specifically the session and assets modules. It is currently a proof of authority network. In general, the Iris-Assets module, which depends on the assets modules, provides data ingestion, and asset class management. The Iris-Session module enables session based storage for content owner, where storage is provided by network validators. Read more on the Iris-assets and Iris-Session modules <a href="./pallets.html">here</a>.</p>
<p><img src="./resources/runtime_modules.png" alt="runtime modules" /></p>
<p>Currently there are four roles that nodes can take in Iris:</p>
<ol>
<li>data owner</li>
<li>data consumer</li>
<li>validator</li>
<li>storage provider</li>
</ol>
<p>In the future another role will be created for moderation and governance capabilities.</p>
<p>Data owners are responsible for adding data to Iris by creating, managing and minting asset classes and assets.</p>
<p>Data consumers are capable of retrieving data from Iris when they hold an asset minted from some owned asset class.</p>
<p>Any validator is capable of being a storage provider. A storage provider is a validator that is actively storing some data associated with an owned asset class. Validators are incentivized to store data by earning reward points when they process IPFS requests or when data they are pinning is accessed.</p>
<p>Below, we see a high-level overview of how these four roles interact with one another. In the near future we intend to create a smart contract to realize an Iris Assets Exchange, a marketplace for data owners and data consumers to buy, sell, and share assets.</p>
<p><img src="./resources/iris_overview.png" alt="iris-overview" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pallets"><a class="header" href="#pallets">Pallets</a></h1>
<p>Iris provides several new pallets on top of those available by default in Substrate.</p>
<ol>
<li><a href="./pallet_iris_assets.html">Iris-Assets</a></li>
<li><a href="./pallet_iris_session.html">Iris-Session</a></li>
<li><a href="./pallet_iris_ledger.html">Iris-Ledger</a></li>
<li>Iris Democracy: Planned</li>
<li>Iris Treasury: Planned</li>
</ol>
<p><img src="./resources/runtime_modules.png" alt="runtime modules" />
<em>Completed and active modules are marked in purple, planned modules in yellow. Dependencies are represented as arrows</em></p>
<h2 id="iris-assets"><a class="header" href="#iris-assets">Iris Assets</a></h2>
<p>The <a href="./pallet_iris_assets.html">Iris-Assets</a> pallet provides functionality for nodes to inject data into Iris, create and manage storage asset classes and to mint and burn assets.</p>
<h2 id="iris-session"><a class="header" href="#iris-session">Iris Session</a></h2>
<p>The <a href="./pallet_iris_session.html">Iris-Session</a> pallet provides session-based storage capabilities for network validators as well as enables ejecting data from the network. The iris-session palelt contains all functionality to interact with the embedded IPFS node. While a strict content-owner only node does not require the iris-session pallet, for both consumers and storage providers it is a necessity.</p>
<h2 id="iris-ledger"><a class="header" href="#iris-ledger">Iris Ledger</a></h2>
<p>The <a href="./pallets_iris_ledger.html">Iris-Ledger</a> pallet allows nodes to lock, unlock, and transfer native tokens.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-assets-1"><a class="header" href="#iris-assets-1">Iris-Assets</a></h1>
<p>Please reference the documentation <a href="TODO">here</a> for further details on extrinsics exposed by the module.</p>
<p>The iris-assets module relies on the <a href="https://github.com/paritytech/substrate/blob/master/frame/assets/README.md">assets module</a> available in Substrate. This pallet provides capabilities for content owners and content consumers. This module is entirely independent of IPFS. It provides capabilities to:</p>
<ul>
<li>inject data into the network</li>
<li>create and manage storage asset classes</li>
<li>mint assets</li>
</ul>
<p>The iris-assets module delivers asset class and derived asset management. This module appends commands to a DataQueue which are processed by validator nodes (see the <a href="./pallets_iris_session.html">iris-session</a> module for more info) in a module which implements logic for offchain workers to process commands in the DataQueue (in our case, the iris-session pallet).</p>
<h2 id="runtime-details"><a class="header" href="#runtime-details">Runtime Details</a></h2>
<h3 id="extrinsics"><a class="header" href="#extrinsics">Extrinsics</a></h3>
<p>Functions to inject data into the network and to create and manage asset classes and assets</p>
<ul>
<li><code>create</code></li>
<li><code>mint</code></li>
<li><code>burn</code></li>
<li><code>destroy</code></li>
<li><code>transfer_asset</code></li>
</ul>
<p>Function to allow consumers to request data from the network</p>
<ul>
<li><code>request_bytes</code></li>
</ul>
<p>Functions that allow offchain workers to submit results from IPFS commands</p>
<ul>
<li><code>submit_ipfs_add_results</code></li>
<li><code>insert_pin_request</code></li>
</ul>
<h3 id="rpc"><a class="header" href="#rpc">RPC</a></h3>
<p>The iris-assets pallet contains the implementation of the RPC endpoint which fetches dat from the network. See more details <a href="./rpc.html">here</a></p>
<h3 id="data-ownership-as-asset-class-ownership"><a class="header" href="#data-ownership-as-asset-class-ownership">Data Ownership as Asset Class Ownership</a></h3>
<p>When a node adds data to Iris, the OCW that processes the request constructs a new asset class backed by some initial (user defined) amount of native currency. This results in a new <code>DataCommand</code> being added to the processing queue. When an OCW proceses the command and publishes results on chain, a new asset class is created. Asset creation and access is initiated in the iris-assets pallet but processed in the iris-session pallet.</p>
<p><img src="./resources/data_ingestion.drawio.png" alt="data-ingestion" /></p>
<p>Our initial use case makes assumptions that we will break in the future:</p>
<ol>
<li>There is an injective and surjective map between owner/cid and asset class.</li>
<li>Owning any non-zero quantity of assets in an asset class grants the owner access to the underlying data</li>
</ol>
<h3 id="accessing-data-via-minted-assets"><a class="header" href="#accessing-data-via-minted-assets">Accessing Data Via Minted Assets</a></h3>
<p>To retrieve data, a node makes a request to Iris, adding a request to retrieve bytes to the queue. An OCW processes the command and adds the fetched content to local offchain storage. The node which requested the data can then invoke the <code>iris_retrieveBytes</code> RPC endpoint exposed on the node who fetched the content in order to retrieve it.</p>
<p>First, a node that owns some positive balance of an asset requests access to it. When this request is processed by the calling node's OCW, the OCW stores the data in offchain storage. When the RPC endpoint is invoked, the data is returned to the authorized caller in the response.</p>
<p><img src="./resources/data_ejection_p1.drawio.png" alt="data-ejection part 1" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-session-1"><a class="header" href="#iris-session-1">Iris-Session</a></h1>
<p>The Iris-session pallet incorporates both IPFS and the <a href="https://github.com/paritytech/substrate/blob/master/frame/session/README.md">session module</a> to allow network validators to provide storage for some existing asset class for the duration of a session. In general, it provides the capabilities to:</p>
<ul>
<li>provide storage to the network</li>
<li>capitalize on latent storage capacity</li>
<li>eject data from the network</li>
</ul>
<h2 id="runtime-details-1"><a class="header" href="#runtime-details-1">Runtime Details</a></h2>
<h3 id="interaction-with-embedded-ipfs"><a class="header" href="#interaction-with-embedded-ipfs">Interaction with Embedded IPFS</a></h3>
<p>The iris-session pallet contains the core logic for interacting with the embedded IPFS instance. In this module we expose the capability for offchain workers to process commands added to the DataQueue. Specifically, to:</p>
<ul>
<li>read IPFS public key and muiltiaddresses</li>
<li>add data to the IPFS by processing an AddBytes command</li>
<li>fetch data from IPFS by processing a CatBytes command</li>
<li>pin data to IPFS by processing a PinBytes command</li>
</ul>
<p>When a node adds an AddBytes command to the queue (via the iris-assets pallet), any other node is capable of processing the command and injecting the data into the network.</p>
<p>When a node adds a CatBytes command to the queue, it is uniquely processed by the calling node, adding the data to offchain storage so that it can be fetched via the RPC endpoint.</p>
<p>When a node adds a PinBytes command to the queue, it is uniquely processed by the calling node. The also results in the addition of the node to the <em>Pinners</em> storage map.</p>
<h3 id="session-based-approach-to-adding-validators"><a class="header" href="#session-based-approach-to-adding-validators">Session-based approach to adding validators</a></h3>
<p>Iris is a proof of authority network. Through the usage of the session pallet, we introduce a mechanism for an existing authority to add new validators to the network. Iris uses Aura for consensus and Grandpa for block finalization and there is no alteration to the default process through which nodes are rewarded.</p>
<p>In the long term, we intend to create a new consensus, which we are calling <code>Nominated Proof of Storage Capacity</code>. Details of this to come.</p>
<h3 id="session-based-approach-to-adding-and-rewarding-storage-providers"><a class="header" href="#session-based-approach-to-adding-and-rewarding-storage-providers">Session-based approach to adding and rewarding storage providers</a></h3>
<p><em>Note</em>: We currently follow a fairly naive scheme for incentivizing validators to store content. We intend to replace the below scheme with something much more mature in the future.</p>
<p>Validator nodes are a superset of the storage provider nodes. Validators, using the iris-session pallet, can request to store some owned content added to Iris. For example, if a node has added data and created a content asset class, then a validator node can request to store the content during the subsequent session.</p>
<p>There are three phases to each session:</p>
<ol>
<li>a pre-session planning phase</li>
<li>a session start phase</li>
<li>a session end phase</li>
</ol>
<p>When we say <strong>current session</strong> we mean a session that has been <em>planned</em>, and for which the possible storage providers are locked but not yet necessarily providing active storage. An <strong>active session</strong> is a session that has been <em>started</em> and for which the nodes are active storage providers. This is elaborated below:</p>
<ol>
<li>
<p>Pre-session planning: candidate storage providers that have pinned the CID they requested to store are added to a collection of active storage providers for that asset class for that session. The current session is incremented by one.</p>
</li>
<li>
<p>Session Start: The active session is incremented by one.</p>
</li>
<li>
<p>Session End: Validiators that have been storing data but have not accumulated any reward points for some preconfigured number of sessions (MaxDeadSessions) is removed from the validator pool.</p>
</li>
</ol>
<h3 id="reward-point-calculation"><a class="header" href="#reward-point-calculation">Reward Point Calculation</a></h3>
<p>Reward points are the interim rewards that storage providers receive for processing requests in the DataQueue. DataCommands are added to the DataQueue when:</p>
<ul>
<li>a content owner has requested to add data to Iris via the <code>create</code> extrinsic</li>
<li>successfully pinning data</li>
<li>a consumer has requested to fetch bytes from ipfs through the <code>retrieve_data</code> extrinsic.</li>
</ul>
<p>When data is requested from Iris, the underlying IPFS network will fetch the bytes from one of the storage providers (though it's possible it could exist in another node since we don't have much in terms of garbage collection in rust-ipfs). Though it may be possible to determine exactly which IPFS node the data was fetched from, this is most likely computationally expensive. We track the number of times some data was successfully requested (i.e. the number of times a consumer requested to fetch the content of an asset class of which they own an asset). At the end of the session, the total sum is distributed evenly to storage providers for that asset during the session.</p>
<p>Validators are rewarded for:</p>
<ul>
<li>Processing requests to inject data into IPFS (basically <code>ipfs add [cid]</code>)
<ul>
<li>Awarded 1 RP</li>
</ul>
</li>
<li>Pinning data to their embedded IPFS node (<code>ipfs pin [cid]</code>)
<ul>
<li>Awarded 1 RP</li>
</ul>
</li>
<li>Indirectly, when another node requests data they are providing storage for
<ul>
<li>The number of unallocated tokens for the session is incremented by 1</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-ledger-1"><a class="header" href="#iris-ledger-1">Iris-Ledger</a></h1>
<p>The ledger pallet is a utility pallet meant to facilitate locking and unlocking of funds to ensure existence of funds when buying and selling assets within the iris ecosystem.</p>
<h2 id="runtime-details-2"><a class="header" href="#runtime-details-2">Runtime Details</a></h2>
<h3 id="extrinsics-1"><a class="header" href="#extrinsics-1">Extrinsics</a></h3>
<ul>
<li><code>lock</code> - lock some amount of native tokens</li>
<li><code>unlock_and_transfer</code> - unlock the locked tokens and transfer all to some specified account</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc-1"><a class="header" href="#rpc-1">RPC</a></h1>
<p>Iris only exposes one custom RPC endpoint. The retreiveBytes endpoint allows authorized nodes to fetch data from the iris network.</p>
<h2 id="spec"><a class="header" href="#spec">Spec</a></h2>
<ul>
<li><code>iris_retrieveBytes</code></li>
<li>Description: This RPC endpoint allows external origins to access data to which they have been granted access.</li>
<li>Parameters:
<ul>
<li>asset_id: The desired asset id</li>
</ul>
</li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>The RPC endpoint reads from offchain storage to fetch the bytes.</p>
<p>Invocation of this endpoint necessitates a few prerequisites:</p>
<ol>
<li>The node owns an asset minted from some asset class</li>
<li>Some node is storing the data in the embedded IPFS node, be it a storage provider, the data owner, or just some other consumer who has already requested the data.</li>
<li>The node has invoked the <code>request_bytes</code> extrinsic, which fetches the data from IPFS and adds it to offchain storage</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Assume that you have requested access to some CID: QmVsbXUbr5JwUDibTBmmh224GhWy1FWguTbHb3DTU3ahTE. First, convert the CID to hex: 0x516d56736258556272354a775544696254426d6d6832323447685779314657677554624862334454553361685445</p>
<p>and use it as the message field value, passing empty bytes to the other fields.</p>
<p>curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d '{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: &quot;1&quot;, &quot;method&quot;: &quot;iris_retrieveBytes&quot;, &quot;params&quot;: [&quot;392&quot;]}'</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-smart-contracts-on-iris"><a class="header" href="#building-smart-contracts-on-iris">Building smart contracts on iris</a></h1>
<p>Iris leverages the contracts module to allow users to deploy their own contracts to the iris blockchain. We enable developers to build dapps that take advantage of the iris runtime. In particular, Iris exposes a chain extension that provides functionality to call into the iris runtime from contracts deployed to the chain.</p>
<h2 id="dapps-on-iris"><a class="header" href="#dapps-on-iris">DApps on Iris</a></h2>
<h3 id="the-iris-asset-exchange"><a class="header" href="#the-iris-asset-exchange">The Iris Asset Exchange</a></h3>
<p>The first app built on Iris is an asset exchange to allow data owners to sell access to data consumers.</p>
<p><a href="./contracts_asset_exchange.html">Iris Asset Exchange</a></p>
<h3 id="developing-a-dapp"><a class="header" href="#developing-a-dapp">Developing a dapp</a></h3>
<h4 id="the-iris-chain-extension"><a class="header" href="#the-iris-chain-extension">The Iris Chain extension</a></h4>
<p><a href="./contracts_chain_extension.html">chain extension</a></p>
<h3 id="deploying-a-dapp"><a class="header" href="#deploying-a-dapp">Deploying a dapp</a></h3>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chain-extension"><a class="header" href="#chain-extension">Chain Extension</a></h1>
<p>The iris chain extension provides functionality for dapp developers to hook into the iris runtime. More specifically, it exposes the ability to call extrinsics from the iris-assets pallet and the iris-ledger pallet to enable developers to manage assets via mint and transfer abilities and to lock, unlock, and transfer tokens to other accounts.</p>
<h2 id="exposed-functions"><a class="header" href="#exposed-functions">Exposed Functions</a></h2>
<h3 id="from-the-iris-assets-pallet"><a class="header" href="#from-the-iris-assets-pallet">From the Iris-Assets pallet</a></h3>
<p>See the <a href="./pallets_iris_assets.html">iris-assets</a> for more details.</p>
<ul>
<li>
<p>mint</p>
</li>
<li>
<p>transfer_assets</p>
</li>
</ul>
<h2 id="from-the-iris-ledger-pallet"><a class="header" href="#from-the-iris-ledger-pallet">From the Iris-Ledger pallet</a></h2>
<p>See the <a href="./pallets_iris_ledger.html">iris-ledger</a> for more details.</p>
<ul>
<li>
<p>lock_currency</p>
</li>
<li>
<p>unlock_and_transfer_currency</p>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To functions from the chain extension in your smart contract, register the chain extension:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink::chain_extension]
pub trait Iris {
    type ErrorCode = IrisErr;

    #[ink(extension = 0, returns_result = false)]
    fn transfer_asset(
        contract_account: ink_env::AccountId, 
        consumer_account: ink_env::AccountId, 
        asset_id: u32, 
        asset_quantity: u64
    ) -&gt; [u8; 32];

    #[ink(extension = 1, returns_result = false)]
    fn mint(caller: ink_env::AccountId, target: ink_env::AccountId, asset_id: u32, amount: u64) -&gt; [u8; 32];

    #[ink(extension = 2, returns_result = false)]
    fn lock(amount: u64) -&gt; [u8; 32];

    #[ink(extension = 3, returns_result = false)]
    fn unlock_and_transfer(target: ink_env::AccountId) -&gt; [u8; 32];
} 
<span class="boring">}
</span></code></pre></pre>
<p>and invoke the chain extension function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> self.env()
    .extension()
    .mint(
        caller, self.env().account_id(), asset_id, amount,
    ).map_err(|_| {}).ok();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iris-asset-exchange"><a class="header" href="#iris-asset-exchange">Iris Asset Exchange</a></h1>
<p>The Iris Asset Exchange is a decentralized exchange to facilitate the buying and selling of assets in Iris.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>The source code and README for the IAE is located <a href="https://github.com/ideal-labs/contracts/tree/main/iris_asset_exchange">here</a>.</p>
<p>The iris-ui exposes a user interface to interact with the contract.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="publish_token_sale"><a class="header" href="#publish_token_sale">publish_token_sale</a></h3>
<p>Mint new tokens and gives ownership of them to the contract account. The owner specifies a static price that consumers pay in order to purchase the asset.</p>
<p>Parameters:</p>
<ul>
<li>asset_id: The id of some owned asset</li>
<li>quantity: The quanity of assets to mint and transfer to the contract</li>
<li>price: The price per minted asset</li>
</ul>
<h3 id="purchase_tokens"><a class="header" href="#purchase_tokens">purchase_tokens</a></h3>
<ol>
<li>lock price*amount tokens</li>
<li>transfer tokens to the caller (from the contract account)</li>
<li>unlock tokens</li>
<li>caller transfer tokens to the owner</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="governance-and-moderation"><a class="header" href="#governance-and-moderation">Governance and Moderation</a></h1>
<p>Governance and decentralized moderation are planned for the future and do not currently exist within Iris.</p>
<p>We intend for there to be three layers to this.
Layer 0: Automod capabilities via some ML algorithm.
Layer 1: User initiated reporting and reviewing/reputation score buildup
Layer 2: Democratically elected moderators to provide human input - much the same as moderators exist today.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>asset</li>
<li>asset class</li>
<li>cid</li>
<li>ipfs</li>
<li>multiaddress</li>
<li>substrate</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
